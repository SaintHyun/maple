import axios, { AxiosError } from 'axios';
import dayjs from 'dayjs';
import xml2js from 'xml2js';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var timezone$1 = {exports: {}};

(function (module, exports) {
!function(t,e){module.exports=e();}(commonjsGlobal,(function(){var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,a=function(t,n,i){void 0===i&&(i={});var o=new Date(t),r=function(t,n){void 0===n&&(n={});var i=n.timeZoneName||"short",o=t+"|"+i,r=e[o];return r||(r=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:t,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",timeZoneName:i}),e[o]=r),r}(n,i);return r.formatToParts(o)},u=function(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10));}var d=r[3],l=24===d?0:d,h=r[0]+"-"+r[1]+"-"+r[2]+" "+l+":"+r[4]+":"+r[5]+":000",v=+e;return (o.utc(h).valueOf()-(v-=v%1e3))/6e4},f=i.prototype;f.tz=function(t,e){void 0===t&&(t=r);var n=this.utcOffset(),i=this.toDate(),a=i.toLocaleString("en-US",{timeZone:t}),u=Math.round((i-new Date(a))/1e3/60),f=o(a,{locale:this.$L}).$set("millisecond",this.$ms).utcOffset(15*-Math.round(i.getTimezoneOffset()/15)-u,!0);if(e){var s=f.utcOffset();f=f.add(n-s,"minute");}return f.$x.$timezone=t,f},f.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find((function(t){return "timezonename"===t.type.toLowerCase()}));return n&&n.value};var s=f.startOf;f.startOf=function(t,e){if(!this.$x||!this.$x.$timezone)return s.call(this,t,e);var n=o(this.format("YYYY-MM-DD HH:mm:ss:SSS"),{locale:this.$L});return s.call(n,t,e).tz(this.$x.$timezone,!0)},o.tz=function(t,e,n){var i=n&&e,a=n||e||r,f=u(+o(),a);if("string"!=typeof t)return o(t).tz(a);var s=function(t,e,n){var i=t-60*e*1e3,o=u(i,n);if(e===o)return [i,e];var r=u(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)]}(o.utc(t,i).valueOf(),f,a),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=a,d},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(t){r=t;};}}));
}(timezone$1));

var timezone = timezone$1.exports;

var utc$1 = {exports: {}};

(function (module, exports) {
!function(t,i){module.exports=i();}(commonjsGlobal,(function(){var t="minute",i=/[+-]\d\d(?::?\d\d)?/g,e=/([+-]|\d\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t);};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds();}else r.call(this);};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if("string"==typeof s&&(s=function(t){void 0===t&&(t="");var s=t.match(i);if(!s)return null;var f=(""+s[0]).match(e)||["-",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:"+"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r;}else o=this.utc();return o};var h=u.format;u.format=function(t){var i=t||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return !!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return "s"===t&&this.$offset?n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)};}}));
}(utc$1));

var utc = utc$1.exports;

/**
 * 업적 랭킹 정보
 */
class AchievementRankingDto {
    /**
     * 랭킹 업데이트 일자 (KST, 일 단위 데이터로 시, 분은 일괄 0으로 표기)
     */
    date;
    /**
     * 업적 랭킹 순위
     */
    ranking;
    /**
     * 캐릭터 명
     */
    characterName;
    /**
     * 월드 명
     */
    worldName;
    /**
     * 직업 명
     */
    className;
    /**
     * 전직 직업 명
     */
    subClassName;
    /**
     * 업적 등급
     */
    trophyGrade;
    /**
     * 업적 점수
     */
    trophyScore;
    constructor(obj) {
        const { date, ranking, character_name, world_name, class_name, sub_class_name, trophy_grade, trophy_score, } = obj;
        this.date = new Date(date);
        this.ranking = ranking;
        this.characterName = character_name;
        this.worldName = world_name;
        this.className = class_name;
        this.subClassName = sub_class_name;
        this.trophyGrade = trophy_grade;
        this.trophyScore = trophy_score;
    }
}

/**
 * 업적 랭킹 응답 정보
 */
class AchievementRankingResponseDto {
    /**
     * 업적 랭킹 정보
     */
    ranking;
    constructor(obj) {
        const { ranking } = obj;
        this.ranking = ranking.map((rank) => new AchievementRankingDto(rank));
    }
}

/**
 * 캐릭터 어빌리티 상세 정보
 */
class CharacterAbilityInfoDto {
    abilityNo;
    abilityGrade;
    abilityValue;
    constructor(obj) {
        const { ability_no, ability_grade, ability_value } = obj;
        this.abilityNo = ability_no;
        this.abilityGrade = ability_grade;
        this.abilityValue = ability_value;
    }
}

/**
 * 캐릭터 어빌리티 정보
 */
class CharacterAbilityDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 어빌리티 등급
     */
    abilityGrade;
    /**
     *  어빌리티 정보
     */
    abilityInfo;
    /**
     * 보유 명성치
     */
    remainFame;
    constructor(obj) {
        const { date, ability_grade, ability_info, remain_fame } = obj;
        // 날짜는 Date 객체로 변환
        this.date = new Date(date);
        this.abilityGrade = ability_grade;
        this.abilityInfo = ability_info.map((info) => new CharacterAbilityInfoDto(info));
        this.remainFame = remain_fame;
    }
}

/**
 * 캐릭터 안드로이드 캐시 아이템 컬러링프리즘 정보
 */
class CharacterAndroidCashItemEquipmentColoringPrismDto {
    /**
     * 컬러링프리즘 색상 범위
     */
    colorRange;
    /**
     * 컬러링프리즘 색조
     */
    hue;
    /**
     * 컬러링프리즘 채도
     */
    saturation;
    /**
     * 컬러링프리즘 명도
     */
    value;
    constructor(obj) {
        const { color_range, hue, saturation, value } = obj;
        this.colorRange = color_range;
        this.hue = hue;
        this.saturation = saturation;
        this.value = value;
    }
}

/**
 * 캐릭터 안드로이드 캐시 아이템 옵션 정보
 */
class CharacterAndroidCashItemEquipmentOptionDto {
    /**
     * 옵션 타입
     */
    optionType;
    /**
     * 옵션 값
     */
    optionValue;
    constructor(obj) {
        const { option_type, option_value } = obj;
        this.optionType = option_type;
        this.optionValue = option_value;
    }
}

/**
 * 캐릭터 안드로이드 캐시 아이템 장착 정보
 */
class CharacterAndroidCashItemEquipmentDto {
    /**
     * 안드로이드 캐시 아이템 부위 명
     */
    cashItemEquipmentPart;
    /**
     * 안드로이드 캐시 아이템 슬롯 위치
     */
    cashItemEquipmentSlot;
    /**
     * 안드로이드 캐시 아이템 명
     */
    cashItemName;
    /**
     * 안드로이드 캐시 아이템 아이콘
     */
    cashItemIcon;
    /**
     * 안드로이드 캐시 아이템 설명
     */
    cashItemDescription;
    /**
     * 안드로이드 캐시 아이템 옵션
     */
    cashItemOption;
    /**
     * 안드로이드 캐시 아이템 유효 기간 (KST)
     */
    dateExpire;
    /**
     * 안드로이드 캐시 아이템 옵션 유효 기간 (KST, 시간 단위 데이터로 분은 일괄 0으로 표기)
     */
    dateOptionExpire;
    /**
     * 안드로이드 캐시 아이템 라벨 정보 (스페셜라벨, 레드라벨, 블랙라벨, 마스터라벨)
     */
    cashItemLabel;
    /**
     * 안드로이드 캐시 아이템 컬러링프리즘 정보
     */
    cashItemColoringPrism;
    constructor(obj) {
        const { cash_item_equipment_part, cash_item_equipment_slot, cash_item_name, cash_item_icon, cash_item_description, cash_item_option, date_expire, date_option_expire, cash_item_label, cash_item_coloring_prism, } = obj;
        this.cashItemEquipmentPart = cash_item_equipment_part;
        this.cashItemEquipmentSlot = cash_item_equipment_slot;
        this.cashItemName = cash_item_name;
        this.cashItemIcon = cash_item_icon;
        this.cashItemDescription = cash_item_description;
        this.cashItemOption = cash_item_option.map((option) => new CharacterAndroidCashItemEquipmentOptionDto(option));
        this.dateExpire = date_expire ? new Date(date_expire) : null;
        this.dateOptionExpire = date_option_expire
            ? new Date(date_option_expire)
            : null;
        this.cashItemLabel = cash_item_label;
        this.cashItemColoringPrism = cash_item_coloring_prism
            ? new CharacterAndroidCashItemEquipmentColoringPrismDto(cash_item_coloring_prism)
            : null;
    }
}

/**
 * 캐릭터 안드로이드 성형 정보
 */
class CharacterAndroidEquipmentFaceDto {
    /**
     * 안드로이드 성형 명
     */
    faceName;
    /**
     * 안드로이드 성형 베이스 컬러
     */
    baseColor;
    /**
     * 안드로이드 성형 믹스 컬러
     */
    mixColor;
    /**
     * 안드로이드 성형 믹스 컬러의 염색 비율
     */
    mixRate;
    constructor(obj) {
        const { face_name, base_color, mix_color, mix_rate } = obj;
        this.faceName = face_name;
        this.baseColor = base_color;
        this.mixColor = mix_color;
        this.mixRate = mix_rate;
    }
}

/**
 * 캐릭터 안드로이드 헤어 정보
 */
class CharacterAndroidEquipmentHairDto {
    /**
     * 안드로이드 헤어 명
     */
    hairName;
    /**
     * 안드로이드 헤어 베이스 컬러
     */
    baseColor;
    /**
     * 안드로이드 헤어 믹스 컬러
     */
    mixColor;
    /**
     * 안드로이드 헤어 믹스 컬러의 염색 비율
     */
    mixRate;
    constructor(obj) {
        const { hair_name, base_color, mix_color, mix_rate } = obj;
        this.hairName = hair_name;
        this.baseColor = base_color;
        this.mixColor = mix_color;
        this.mixRate = mix_rate;
    }
}

/**
 * 캐릭터 안드로이드 장비 정보
 */
class CharacterAndroidEquipmentDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 안드로이드 명
     */
    androidName;
    /**
     * 안드로이드 닉네임
     */
    androidNickname;
    /**
     * 안드로이드 아이콘
     */
    androidIcon;
    /**
     * 안드로이드 아이템 설명
     */
    androidDescription;
    /**
     * 안드로이드 헤어 정보
     */
    androidHair;
    /**
     * 안드로이드 성형 정보
     */
    androidFace;
    /**
     * 안드로이드 피부 명
     */
    androidSkinName;
    /**
     * 안드로이드 캐시 아이템 장착 정보
     */
    androidCashItemEquipment;
    /**
     * 안드로이드 이어센서 클립 적용 여부
     */
    androidEarSensorClipFlag;
    constructor(obj) {
        const { date, android_name, android_nickname, android_icon, android_description, android_hair, android_face, android_skin_name, android_cash_item_equipment, android_ear_sensor_clip_flag, } = obj;
        this.date = new Date(date);
        this.androidName = android_name;
        this.androidNickname = android_nickname;
        this.androidIcon = android_icon;
        this.androidDescription = android_description;
        this.androidHair = new CharacterAndroidEquipmentHairDto(android_hair);
        this.androidFace = new CharacterAndroidEquipmentFaceDto(android_face);
        this.androidSkinName = android_skin_name;
        this.androidCashItemEquipment = android_cash_item_equipment.map((equipment) => new CharacterAndroidCashItemEquipmentDto(equipment));
        this.androidEarSensorClipFlag = android_ear_sensor_clip_flag ?? null;
    }
}

/**
 * 캐릭터 기본 정보
 */
class CharacterBasicDto {
    date;
    /**
     * 캐릭터 명
     */
    characterName;
    /**
     * 월드 명
     */
    worldName;
    /**
     * 캐릭터 성별
     */
    characterGender;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * 캐릭터 전직 차수
     */
    characterClassLevel;
    /**
     * 캐릭터 레벨
     */
    characterLevel;
    /**
     * 현재 레벨에서 보유한 경험치
     */
    characterExp;
    /**
     * 현재 레벨에서 경험치 퍼센트
     */
    characterExpRate;
    /**
     * 캐릭터 소속 길드 명
     */
    characterGuildName;
    /**
     * 캐릭터 외형 이미지
     */
    characterImage;
    constructor(obj) {
        const { date, character_name, world_name, character_gender, character_class, character_class_level, character_level, character_exp, character_exp_rate, character_guild_name, character_image, } = obj;
        this.date = new Date(date);
        this.characterName = character_name;
        this.worldName = world_name;
        this.characterGender = character_gender;
        this.characterClass = character_class;
        this.characterClassLevel = character_class_level;
        this.characterLevel = character_level;
        this.characterExp = character_exp;
        this.characterExpRate = character_exp_rate;
        this.characterGuildName = character_guild_name;
        this.characterImage = character_image;
    }
}

/**
 * 캐릭터 성형 정보
 */
class CharacterBeautyEquipmentFaceDto {
    /**
     * 성형 명
     */
    faceName;
    /**
     * 성형 베이스 컬러
     */
    baseColor;
    /**
     * 성형 믹스 컬러
     */
    mixColor;
    /**
     * 성형 믹스 컬러의 염색 비율
     */
    mixRate;
    constructor(obj) {
        const { face_name, base_color, mix_color, mix_rate } = obj;
        this.faceName = face_name;
        this.baseColor = base_color;
        this.mixColor = mix_color;
        this.mixRate = mix_rate;
    }
}

/**
 * 캐릭터 헤어 정보
 */
class CharacterBeautyEquipmentHairDto {
    /**
     * 헤어 명
     */
    hairName;
    /**
     * 헤어 베이스 컬러
     */
    baseColor;
    /**
     * 헤어 믹스 컬러
     */
    mixColor;
    /**
     * 헤어 믹스 컬러의 염색 비율
     */
    mixRate;
    constructor(obj) {
        const { hair_name, base_color, mix_color, mix_rate } = obj;
        this.hairName = hair_name;
        this.baseColor = base_color;
        this.mixColor = mix_color;
        this.mixRate = mix_rate;
    }
}

/**
 * 캐릭터 헤어, 성형, 피부 정보
 */
class CharacterBeautyEquipmentDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 성별
     */
    characterGender;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * 캐릭터 헤어 정보<br>
     * (제로인 경우 알파, 엔젤릭버스터인 경우 일반 모드)
     */
    characterHair;
    /**
     * 캐릭터 성형 정보<br>
     * (제로인 경우 알파, 엔젤릭버스터인 경우 일반 모드)
     */
    characterFace;
    /**
     * 피부 명<br>
     * (제로인 경우 알파, 엔젤릭버스터인 경우 일반 모드)
     */
    characterSkinName;
    /**
     * 제로인 경우 베타, 엔젤릭버스터인 경우 드레스 업 모드에 적용 중인 헤어 정보
     */
    additionalCharacterHair;
    /**
     * 제로인 경우 베타, 엔젤릭버스터인 경우 드레스 업 모드에 적용 중인 성형 정보
     */
    additionalCharacterFace;
    /**
     * 제로인 경우 베타, 엔젤릭버스터인 경우 드레스 업 모드에 적용 중인 피부 명
     */
    additionalCharacterSkinName;
    constructor(obj) {
        const { date, character_gender, character_class, character_hair, character_face, character_skin_name, additional_character_hair, additional_character_face, additional_character_skin_name, } = obj;
        this.date = new Date(date);
        this.characterGender = character_gender;
        this.characterClass = character_class;
        this.characterHair = new CharacterBeautyEquipmentHairDto(character_hair);
        this.characterFace = new CharacterBeautyEquipmentFaceDto(character_face);
        this.characterSkinName = character_skin_name;
        this.additionalCharacterHair = additional_character_hair
            ? new CharacterBeautyEquipmentHairDto(additional_character_hair)
            : null;
        this.additionalCharacterFace = additional_character_face
            ? new CharacterBeautyEquipmentFaceDto(additional_character_face)
            : null;
        this.additionalCharacterSkinName = additional_character_skin_name;
    }
}

/**
 * 캐릭터 캐시 장비 컬러링프리즘
 */
class CharacterCashItemEquipmentColoringPrismDto {
    /**
     * 컬러링프리즘 색상 범위
     */
    colorRange;
    /**
     * 컬러링프리즘 색조
     */
    hue;
    /**
     * 컬러링프리즘 채도
     */
    saturation;
    /**
     * 컬러링프리즘 명도
     */
    value;
    constructor(obj) {
        const { color_range, hue, saturation, value } = obj;
        this.colorRange = color_range;
        this.hue = hue;
        this.saturation = saturation;
        this.value = value;
    }
}

/**
 * 캐릭터 캐시 장비 옵션
 */
class CharacterCashItemEquipmentOptionDto {
    /**
     * 옵션 타입
     */
    optionType;
    /**
     * 옵션 값
     */
    optionValue;
    constructor(obj) {
        const { option_type, option_value } = obj;
        this.optionType = option_type;
        this.optionValue = option_value;
    }
}

/**
 * 캐릭터 프리셋 장착 캐시 장비 정보
 */
class CharacterCashItemEquipmentPresetDto {
    /**
     * 캐시 장비 부위 명
     */
    cashItemEquipmentPart;
    /**
     * 캐시 장비 슬롯 위치
     */
    cashItemEquipmentSlot;
    /**
     * 캐시 장비 명
     */
    cashItemName;
    /**
     * 캐시 장비 아이콘
     */
    cashItemIcon;
    /**
     * 캐시 장비 설명
     */
    cashItemDescription;
    /**
     * 캐시 장비 옵션
     */
    cashItemOption;
    /**
     * 캐시 장비 유효 기간 (KST)
     */
    dateExpire;
    /**
     * 캐시 장비 옵션 유효 기간 (KST, 시간 단위 데이터로 분은 일괄 0으로 표기)
     */
    dateOptionExpire;
    /**
     * 캐시 장비 라벨 정보
     */
    cashItemLabel;
    /**
     * 캐시 장비 컬러링프리즘 정보
     */
    cashItemColoringPrism;
    /**
     * 다른 프리셋에서 장비 추가 장착 없이 1번 프리셋의 장비 공유를 비활성화 했는지 여부
     */
    basePresetItemDisableFlag;
    constructor(obj) {
        const { cash_item_equipment_part, cash_item_equipment_slot, cash_item_name, cash_item_icon, cash_item_description, cash_item_option, date_expire, date_option_expire, cash_item_label, cash_item_coloring_prism, base_preset_item_disable_flag, } = obj;
        this.cashItemEquipmentPart = cash_item_equipment_part;
        this.cashItemEquipmentSlot = cash_item_equipment_slot;
        this.cashItemName = cash_item_name;
        this.cashItemIcon = cash_item_icon;
        this.cashItemDescription = cash_item_description;
        this.cashItemOption = cash_item_option.map((option) => new CharacterCashItemEquipmentOptionDto(option));
        this.dateExpire = date_expire;
        this.dateOptionExpire = date_option_expire;
        this.cashItemLabel = cash_item_label;
        this.cashItemColoringPrism = cash_item_coloring_prism
            ? new CharacterCashItemEquipmentColoringPrismDto(cash_item_coloring_prism)
            : null;
        this.basePresetItemDisableFlag = base_preset_item_disable_flag;
    }
}

/**
 * 캐릭터 캐시 장비 아이템 정보
 */
class CharacterCashItemEquipmentDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 성별
     */
    characterGender;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * 적용 중인 캐시 장비 프리셋 번호
     */
    presetNo;
    /**
     * 1번 프리셋 장착 캐시 장비 정보
     */
    cashItemEquipmentPreset1;
    /**
     * 2번 프리셋 장착 캐시 장비 정보
     */
    cashItemEquipmentPreset2;
    /**
     * 3번 프리셋 장착 캐시 장비 정보
     */
    cashItemEquipmentPreset3;
    /**
     * 제로인 경우 베타, 엔젤릭버스터인 경우 드레스 업 모드의 1번 프리셋 장착 캐시 장비 정보
     */
    additionalCashItemEquipmentPreset1;
    /**
     * 제로인 경우 베타, 엔젤릭버스터인 경우 드레스 업 모드의 2번 프리셋 장착 캐시 장비 정보
     */
    additionalCashItemEquipmentPreset2;
    /**
     * 제로인 경우 베타, 엔젤릭버스터인 경우 드레스 업 모드의 3번 프리셋 장착 캐시 장비 정보
     */
    additionalCashItemEquipmentPreset3;
    constructor(obj) {
        const { date, character_gender, character_class, preset_no, cash_item_equipment_preset_1, cash_item_equipment_preset_2, cash_item_equipment_preset_3, additional_cash_item_equipment_preset_1, additional_cash_item_equipment_preset_2, additional_cash_item_equipment_preset_3, } = obj;
        (this.date = new Date(date)), (this.characterGender = character_gender);
        this.characterClass = character_class;
        this.presetNo = preset_no;
        this.cashItemEquipmentPreset1 = cash_item_equipment_preset_1.map((preset) => new CharacterCashItemEquipmentPresetDto(preset));
        this.cashItemEquipmentPreset2 = cash_item_equipment_preset_2.map((preset) => new CharacterCashItemEquipmentPresetDto(preset));
        this.cashItemEquipmentPreset3 = cash_item_equipment_preset_3.map((preset) => new CharacterCashItemEquipmentPresetDto(preset));
        this.additionalCashItemEquipmentPreset1 =
            additional_cash_item_equipment_preset_1.map((preset) => new CharacterCashItemEquipmentPresetDto(preset));
        this.additionalCashItemEquipmentPreset2 =
            additional_cash_item_equipment_preset_2.map((preset) => new CharacterCashItemEquipmentPresetDto(preset));
        this.additionalCashItemEquipmentPreset3 =
            additional_cash_item_equipment_preset_3.map((preset) => new CharacterCashItemEquipmentPresetDto(preset));
    }
}

/**
 * 캐릭터 도장 정보
 */
class CharacterDojangDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * 월드 명
     */
    worldName;
    /**
     * 무릉도장 최고 기록 층수
     */
    dojangBestFloor;
    /**
     * 무릉도장 최고 기록 달성 일 (KST, 일 단위 데이터로 시, 분은 일괄 0으로 표기)
     */
    dateDojangRecord;
    /**
     * 무릉도장 최고 층수 클리어에 걸린 시간 (초)
     */
    dojangBestTime;
    constructor(obj) {
        const { date, character_class, world_name, dojang_best_floor, date_dojang_record, dojang_best_time, } = obj;
        this.date = new Date(date);
        this.characterClass = character_class;
        this.worldName = world_name;
        this.dojangBestFloor = dojang_best_floor;
        this.dateDojangRecord = date_dojang_record
            ? new Date(date_dojang_record)
            : null;
        this.dojangBestTime = dojang_best_time;
    }
}

/**
 * 캐릭터 식별 정보
 */
class CharacterDto {
    /**
     * 캐릭터 식별자
     */
    ocid;
    constructor(obj) {
        const { ocid } = obj;
        this.ocid = ocid;
    }
}

/**
 * 연결된 HEXA 스킬 정보
 */
class CharacterHexaMatrixEquipmentLinkedSkillDto {
    /**
     * HEXA 스킬 명
     */
    hexaSkillId;
    constructor(obj) {
        const { hexa_skill_id } = obj;
        this.hexaSkillId = hexa_skill_id;
    }
}

/**
 * 캐릭터 HEXA 코어 정보
 */
class CharacterHexaMatrixEquipmentDto {
    /**
     * 코어 명
     */
    hexaCoreName;
    /**
     * 코어 레벨
     */
    hexaCoreLevel;
    /**
     * 코어 타입
     */
    hexaCoreType;
    /**
     * 연결된 스킬 목록
     */
    linkedSkill;
    constructor(obj) {
        const { hexa_core_name, hexa_core_level, hexa_core_type, linked_skill } = obj;
        this.hexaCoreName = hexa_core_name;
        this.hexaCoreLevel = hexa_core_level;
        this.hexaCoreType = hexa_core_type;
        this.linkedSkill = linked_skill.map((skill) => new CharacterHexaMatrixEquipmentLinkedSkillDto(skill));
    }
}

/**
 * 캐릭터 HEXA 코어 정보
 */
class CharacterHexaMatrixDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * HEXA 코어 정보
     */
    characterHexaCoreEquipment;
    constructor(obj) {
        const { date, character_hexa_core_equipment } = obj;
        this.date = new Date(date);
        this.characterHexaCoreEquipment = character_hexa_core_equipment.map((equipment) => new CharacterHexaMatrixEquipmentDto(equipment));
    }
}

/**
 * 캐릭터 HEXA 스탯 코어 정보
 */
class CharacterHexaMatrixStatCoreDto {
    /**
     * 슬롯 인덱스
     */
    slotId;
    /**
     * 메인 스탯 명
     */
    mainStatName;
    /**
     * 첫 번째 서브 명
     */
    subStatName1;
    /**
     * 두 번째 서브 명
     */
    subStatName2;
    /**
     * 메인 스탯 레벨
     */
    mainStatLevel;
    /**
     * 첫 번째 서브 레벨
     */
    subStatLevel1;
    /**
     * 두 번째 서브 레벨
     */
    subStatLevel2;
    /**
     * 스탯 코어 등급
     */
    statGrade;
    constructor(obj) {
        const { slot_id, main_stat_name, sub_stat_name_1, sub_stat_name_2, main_stat_level, sub_stat_level_1, sub_stat_level_2, stat_grade, } = obj;
        this.slotId = slot_id;
        this.mainStatName = main_stat_name;
        this.subStatName1 = sub_stat_name_1;
        this.subStatName2 = sub_stat_name_2;
        this.mainStatLevel = main_stat_level;
        this.subStatLevel1 = sub_stat_level_1;
        this.subStatLevel2 = sub_stat_level_2;
        this.statGrade = stat_grade;
    }
}

/**
 * 캐릭터 HEXA 스탯 코어 정보
 */
class CharacterHexaMatrixStatDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * HEXA 스탯 코어 정보
     */
    characterHexaStatCore;
    /**
     * 프리셋 HEXA 스탯 코어 정보
     */
    presetHexaStatCore;
    constructor(obj) {
        const { date, character_class, character_hexa_stat_core, preset_hexa_stat_core, } = obj;
        this.date = new Date(date);
        this.characterClass = character_class;
        this.characterHexaStatCore = character_hexa_stat_core.map((core) => new CharacterHexaMatrixStatCoreDto(core));
        this.presetHexaStatCore = preset_hexa_stat_core.map((core) => new CharacterHexaMatrixStatCoreDto(core));
    }
}

/**
 * 캐릭터 하이퍼 스탯 프리셋 정보
 */
class CharacterHyperStatPresetDto {
    /**
     * 스탯 종류
     */
    statType;
    /**
     * 스탯 투자 포인트
     */
    statPoint;
    /**
     * 스탯 레벨
     */
    statLevel;
    /**
     * 스탯 상승량
     */
    statIncrease;
    constructor(obj) {
        const { stat_type, stat_point, stat_level, stat_increase } = obj;
        this.statType = stat_type;
        this.statPoint = stat_point;
        this.statLevel = stat_level;
        this.statIncrease = stat_increase;
    }
}

/**
 * 캐릭터 하이퍼 스탯 정보
 */
class CharacterHyperStatDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * 적용 중인 프리셋 번호
     */
    usePresetNo;
    /**
     * 사용 가능한 최대 하이퍼스탯 포인트
     */
    useAvailableHyperStat;
    /**
     * 프리셋 1번 하이퍼 스탯 정보
     */
    hyperStatPreset1;
    /**
     * 프리셋 1번 하이퍼 스탯 잔여 포인트
     */
    hyperStatPreset1RemainPoint;
    /**
     * 프리셋 2번 하이퍼 스탯 정보
     */
    hyperStatPreset2;
    /**
     * 프리셋 2번 하이퍼 스탯 잔여 포인트
     */
    hyperStatPreset2RemainPoint;
    /**
     * 프리셋 3번 하이퍼 스탯 정보
     */
    hyperStatPreset3;
    /**
     * 프리셋 3번 하이퍼 스탯 잔여 포인트
     */
    hyperStatPreset3RemainPoint;
    constructor(obj) {
        const { date, character_class, use_preset_no, use_available_hyper_stat, hyper_stat_preset_1, hyper_stat_preset_1_remain_point, hyper_stat_preset_2, hyper_stat_preset_2_remain_point, hyper_stat_preset_3, hyper_stat_preset_3_remain_point, } = obj;
        this.date = new Date(date);
        this.characterClass = character_class;
        this.usePresetNo = use_preset_no;
        this.useAvailableHyperStat = use_available_hyper_stat;
        this.hyperStatPreset1 = hyper_stat_preset_1.map((preset) => new CharacterHyperStatPresetDto(preset));
        this.hyperStatPreset1RemainPoint = hyper_stat_preset_1_remain_point;
        this.hyperStatPreset2 = hyper_stat_preset_2.map((preset) => new CharacterHyperStatPresetDto(preset));
        this.hyperStatPreset2RemainPoint = hyper_stat_preset_2_remain_point;
        this.hyperStatPreset3 = hyper_stat_preset_3.map((preset) => new CharacterHyperStatPresetDto(preset));
        this.hyperStatPreset3RemainPoint = hyper_stat_preset_3_remain_point;
    }
}

/**
 * 캐릭터 장비 추가 옵션 정보
 */
class CharacterItemEquipmentAddOptionDto {
    /**
     * STR
     */
    str;
    /**
     * DEX
     */
    dex;
    /**
     * INT
     */
    int;
    /**
     * LUK
     */
    luk;
    /**
     * 최대 HP
     */
    maxHp;
    /**
     * 최대 MP
     */
    maxMp;
    /**
     * 공격력
     */
    attackPower;
    /**
     * 마력
     */
    magicPower;
    /**
     * 방어력
     */
    armor;
    /**
     * 이동속도
     */
    speed;
    /**
     * 점프력
     */
    jump;
    /**
     * 보스 공격 시 데미지 증가(%)
     */
    bossDamage;
    /**
     * 데미지(%)
     */
    damage;
    /**
     * 올스탯(%)
     */
    allStat;
    /**
     * 착용 레벨 감소
     */
    equipmentLevelDecrease;
    constructor(obj) {
        const { str, dex, int, luk, max_hp, max_mp, attack_power, magic_power, armor, speed, jump, boss_damage, damage, all_stat, equipment_level_decrease, } = obj;
        this.str = str;
        this.dex = dex;
        this.int = int;
        this.luk = luk;
        this.maxHp = max_hp;
        this.maxMp = max_mp;
        this.attackPower = attack_power;
        this.magicPower = magic_power;
        this.armor = armor;
        this.speed = speed;
        this.jump = jump;
        this.bossDamage = boss_damage;
        this.damage = damage;
        this.allStat = all_stat;
        this.equipmentLevelDecrease = equipment_level_decrease;
    }
}

/**
 * 캐릭터 장비 기본 옵션 정보
 */
class CharacterItemEquipmentBaseOptionDto {
    /**
     * STR
     */
    str;
    /**
     * DEX
     */
    dex;
    /**
     * INT
     */
    int;
    /**
     * LUK
     */
    luk;
    /**
     * 최대 HP
     */
    maxHp;
    /**
     * 최대 MP
     */
    maxMp;
    /**
     * 공격력
     */
    attackPower;
    /**
     * 마력
     */
    magicPower;
    /**
     * 방어력
     */
    armor;
    /**
     * 이동속도
     */
    speed;
    /**
     * 점프력
     */
    jump;
    /**
     * 보스 공격 시 데미지 증가(%)
     */
    bossDamage;
    /**
     * 몬스터 방어율 무시(%)
     */
    ignoreMonsterArmor;
    /**
     * 올스탯(%)
     */
    allStat;
    /**
     * 최대 HP(%)
     */
    maxHpRate;
    /**
     * 최대 MP(%)
     */
    maxMpRate;
    /**
     * 기본 착용 레벨
     */
    baseEquipmentLevel;
    constructor(obj) {
        const { str, dex, int, luk, max_hp, max_mp, attack_power, magic_power, armor, speed, jump, boss_damage, ignore_monster_armor, all_stat, max_hp_rate, max_mp_rate, base_equipment_level, } = obj;
        this.str = str;
        this.dex = dex;
        this.int = int;
        this.luk = luk;
        this.maxHp = max_hp;
        this.maxMp = max_mp;
        this.attackPower = attack_power;
        this.magicPower = magic_power;
        this.armor = armor;
        this.speed = speed;
        this.jump = jump;
        this.bossDamage = boss_damage;
        this.ignoreMonsterArmor = ignore_monster_armor;
        this.allStat = all_stat;
        this.maxHpRate = max_hp_rate;
        this.maxMpRate = max_mp_rate;
        this.baseEquipmentLevel = base_equipment_level;
    }
}

/**
 * 캐릭터 장비 기타 옵션 정보
 */
class CharacterItemEquipmentEtcOptionDto {
    /**
     * STR
     */
    str;
    /**
     * DEX
     */
    dex;
    /**
     * INT
     */
    int;
    /**
     * LUK
     */
    luk;
    /**
     * 최대 HP
     */
    maxHp;
    /**
     * 최대 MP
     */
    maxMp;
    /**
     * 공격력
     */
    attackPower;
    /**
     * 마력
     */
    magicPower;
    /**
     * 방어력
     */
    armor;
    /**
     * 이동속도
     */
    speed;
    /**
     * 점프력
     */
    jump;
    constructor(obj) {
        const { str, dex, int, luk, max_hp, max_mp, attack_power, magic_power, armor, speed, jump, } = obj;
        this.str = str;
        this.dex = dex;
        this.int = int;
        this.luk = luk;
        this.maxHp = max_hp;
        this.maxMp = max_mp;
        this.attackPower = attack_power;
        this.magicPower = magic_power;
        this.armor = armor;
        this.speed = speed;
        this.jump = jump;
    }
}

/**
 * 캐릭터 장비 특별 옵션 정보
 */
class CharacterItemEquipmentExceptionalOptionDto {
    /**
     * STR
     */
    str;
    /**
     * DEX
     */
    dex;
    /**
     * INT
     */
    int;
    /**
     * LUK
     */
    luk;
    /**
     * 최대 HP
     */
    maxHp;
    /**
     * 최대 MP
     */
    maxMp;
    /**
     * 공격력
     */
    attackPower;
    /**
     * 마력
     */
    magicPower;
    constructor(obj) {
        const { str, dex, int, luk, max_hp, max_mp, attack_power, magic_power } = obj;
        this.str = str;
        this.dex = dex;
        this.int = int;
        this.luk = luk;
        this.maxHp = max_hp;
        this.maxMp = max_mp;
        this.attackPower = attack_power;
        this.magicPower = magic_power;
    }
}

/**
 * 캐릭터 장비 스타포스 옵션 정보
 */
class CharacterItemEquipmentStarforceOptionDto {
    /**
     * STR
     */
    str;
    /**
     * DEX
     */
    dex;
    /**
     * INT
     */
    int;
    /**
     * LUK
     */
    luk;
    /**
     * 최대 HP
     */
    maxHp;
    /**
     * 최대 MP
     */
    maxMp;
    /**
     * 공격력
     */
    attackPower;
    /**
     * 마력
     */
    magicPower;
    /**
     * 방어력
     */
    armor;
    /**
     * 이동속도
     */
    speed;
    /**
     * 점프력
     */
    jump;
    constructor(obj) {
        const { str, dex, int, luk, max_hp, max_mp, attack_power, magic_power, armor, speed, jump, } = obj;
        this.str = str;
        this.dex = dex;
        this.int = int;
        this.luk = luk;
        this.maxHp = max_hp;
        this.maxMp = max_mp;
        this.attackPower = attack_power;
        this.magicPower = magic_power;
        this.armor = armor;
        this.speed = speed;
        this.jump = jump;
    }
}

/**
 * 캐릭터 장비 최종 옵션 정보
 */
class CharacterItemEquipmentTotalOptionDto {
    /**
     * STR
     */
    str;
    /**
     * DEX
     */
    dex;
    /**
     * INT
     */
    int;
    /**
     * LUK
     */
    luk;
    /**
     * 최대 HP
     */
    maxHp;
    /**
     * 최대 MP
     */
    maxMp;
    /**
     * 공격력
     */
    attackPower;
    /**
     * 마력
     */
    magicPower;
    /**
     * 방어력
     */
    armor;
    /**
     * 이동속도
     */
    speed;
    /**
     * 점프력
     */
    jump;
    /**
     * 보스 공격 시 데미지 증가(%)
     */
    bossDamage;
    /**
     * 몬스터 방어율 무시(%)
     */
    ignoreMonsterArmor;
    /**
     * 올스탯(%)
     */
    allStat;
    /**
     * 데미지(%)
     */
    damage;
    /**
     * 착용 레벨 감소
     */
    equipmentLevelDecrease;
    /**
     * 최대 HP(%)
     */
    maxHpRate;
    /**
     * 최대 MP(%)
     */
    maxMpRate;
    constructor(obj) {
        const { str, dex, int, luk, max_hp, max_mp, attack_power, magic_power, armor, speed, jump, boss_damage, ignore_monster_armor, all_stat, damage, equipment_level_decrease, max_hp_rate, max_mp_rate, } = obj;
        this.str = str;
        this.dex = dex;
        this.int = int;
        this.luk = luk;
        this.maxHp = max_hp;
        this.maxMp = max_mp;
        this.attackPower = attack_power;
        this.magicPower = magic_power;
        this.armor = armor;
        this.speed = speed;
        this.jump = jump;
        this.bossDamage = boss_damage;
        this.ignoreMonsterArmor = ignore_monster_armor;
        this.allStat = all_stat;
        this.damage = damage;
        this.equipmentLevelDecrease = equipment_level_decrease;
        this.maxHpRate = max_hp_rate;
        this.maxMpRate = max_mp_rate;
    }
}

class CharacterItemEquipmentInfoDto {
    /**
     * 장비 부위 명
     */
    itemEquipmentPart;
    /**
     * 장비 슬롯 위치
     */
    equipmentSlot;
    /**
     * 장비 명
     */
    itemName;
    /**
     * 장비 아이콘
     */
    itemIcon;
    /**
     * 장비 설명
     */
    itemDescription;
    /**
     * 장비 외형
     */
    itemShapeName;
    /**
     * 장비 외형 아이콘
     */
    itemShapeIcon;
    /**
     * 전용 성별
     */
    itemGender;
    /**
     * 장비 최종 옵션
     */
    itemTotalOption;
    /**
     * 장비 기본 옵션
     */
    itemBaseOption;
    /**
     * 잠재능력 등급
     */
    potentialOptionGrade;
    /**
     * 에디셔널 잠재능력 등급
     */
    additionalPotentialOptionGrade;
    /**
     * 잠재능력 첫 번째 옵션
     */
    potentialOption1;
    /**
     * 잠재능력 두 번째 옵션
     */
    potentialOption2;
    /**
     * 잠재능력 세 번째 옵션
     */
    potentialOption3;
    /**
     * 에디셔널 잠재능력 첫 번째 옵션
     */
    additionalPotentialOption1;
    /**
     * 에디셔널 잠재능력 두 번째 옵션
     */
    additionalPotentialOption2;
    /**
     * 에디셔널 잠재능력 세 번째 옵션
     */
    additionalPotentialOption3;
    /**
     * 착용 레벨 증가
     */
    equipmentLevelIncrease;
    /**
     * 장비 특별 옵션
     */
    itemExceptionalOption;
    /**
     * 장비 추가 옵션
     */
    itemAddOption;
    /**
     * 성장 경험치
     */
    growthExp;
    /**
     * 성장 레벨
     */
    growthLevel;
    /**
     * 업그레이드 횟수
     */
    scrollUpgrade;
    /**
     * 가위 사용 가능 횟수 (교환 불가 장비, 가위 횟수가 없는 교환 가능 장비는 255)
     */
    cuttableCount;
    /**
     * 황금 망치 재련 적용 (1:적용, 이외 미 적용)
     */
    goldenHammerFlag;
    /**
     * 복구 가능 횟수
     */
    scrollResilienceCount;
    /**
     * 업그레이드 가능 횟수
     */
    scrollUpgradeableCount;
    /**
     * 소울 명
     */
    soulName;
    /**
     * 소울 옵션
     */
    soulOption;
    /**
     * 장비 기타 옵션
     */
    itemEtcOption;
    /**
     * 강화 단계
     */
    starforce;
    /**
     * 놀라운 장비 강화 주문서 사용 여부 (0:미사용, 1:사용)
     */
    starforceScrollFlag;
    /**
     * 장비 스타포스 옵션
     */
    itemStarforceOption;
    /**
     * 특수 반지 레벨
     */
    specialRingLevel;
    /**
     * 장비 유효 기간
     */
    dateExpire;
    constructor(obj) {
        const { item_equipment_part, equipment_slot, item_name, item_icon, item_description, item_shape_name, item_shape_icon, item_gender, item_total_option, item_base_option, potential_option_grade, additional_potential_option_grade, potential_option_1, potential_option_2, potential_option_3, additional_potential_option_1, additional_potential_option_2, additional_potential_option_3, equipment_level_increase, item_exceptional_option, item_add_option, growth_exp, growth_level, scroll_upgrade, cuttable_count, golden_hammer_flag, scroll_resilience_count, scroll_upgradeable_count, soul_name, soul_option, item_etc_option, starforce, starforce_scroll_flag, item_starforce_option, special_ring_level, date_expire, } = obj;
        this.itemEquipmentPart = item_equipment_part;
        this.equipmentSlot = equipment_slot;
        this.itemName = item_name;
        this.itemIcon = item_icon;
        this.itemDescription = item_description;
        this.itemShapeName = item_shape_name;
        this.itemShapeIcon = item_shape_icon;
        this.itemGender = item_gender;
        this.itemTotalOption = new CharacterItemEquipmentTotalOptionDto(item_total_option);
        this.itemBaseOption = new CharacterItemEquipmentBaseOptionDto(item_base_option);
        this.potentialOptionGrade = potential_option_grade;
        this.additionalPotentialOptionGrade = additional_potential_option_grade;
        this.potentialOption1 = potential_option_1;
        this.potentialOption2 = potential_option_2;
        this.potentialOption3 = potential_option_3;
        this.additionalPotentialOption1 = additional_potential_option_1;
        this.additionalPotentialOption2 = additional_potential_option_2;
        this.additionalPotentialOption3 = additional_potential_option_3;
        this.equipmentLevelIncrease = equipment_level_increase;
        this.itemExceptionalOption = new CharacterItemEquipmentExceptionalOptionDto(item_exceptional_option);
        this.itemAddOption = new CharacterItemEquipmentAddOptionDto(item_add_option);
        this.growthExp = growth_exp;
        this.growthLevel = growth_level;
        this.scrollUpgrade = scroll_upgrade;
        this.cuttableCount = cuttable_count;
        this.goldenHammerFlag = golden_hammer_flag;
        this.scrollResilienceCount = scroll_resilience_count;
        this.scrollUpgradeableCount = scroll_upgradeable_count;
        this.soulName = soul_name;
        this.soulOption = soul_option;
        this.itemEtcOption = new CharacterItemEquipmentEtcOptionDto(item_etc_option);
        this.starforce = starforce;
        this.starforceScrollFlag = starforce_scroll_flag;
        this.itemStarforceOption = new CharacterItemEquipmentStarforceOptionDto(item_starforce_option);
        this.specialRingLevel = special_ring_level;
        this.dateExpire = date_expire ? new Date(date_expire) : null;
    }
}

/**
 * 캐릭터 칭호 아이템 정보
 */
class CharacterItemEquipmentTitleDto {
    /**
     * 칭호 장비 명
     */
    titleName;
    /**
     * 칭호 아이콘
     */
    titleIcon;
    /**
     * 칭호 설명
     */
    titleDescription;
    /**
     * 칭호 유효 기간
     */
    dateExpire;
    /**
     * 칭호 옵션 유효 기간
     */
    dateOptionExpire = null;
    /**
     * 칭호 옵션 유효 기간 만료 여부
     */
    isOptionExpired = null;
    constructor(obj) {
        const { title_name, title_icon, title_description, date_expire, date_option_expire, } = obj;
        this.titleName = title_name;
        this.titleIcon = title_icon;
        this.titleDescription = title_description;
        this.dateExpire = date_expire ? new Date(date_expire) : null;
        if (date_option_expire === 'expired') {
            this.isOptionExpired = true;
        }
        else if (typeof date_option_expire === 'string') {
            this.dateOptionExpire = date_option_expire
                ? new Date(date_option_expire)
                : null;
        }
    }
}

/**
 * 캐릭터 장비 아이템 정보
 */
class CharacterItemEquipmentDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 성별
     */
    characterGender;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * 장비 정보 배열
     */
    itemEquipment;
    /**
     * 칭호 정보
     */
    title;
    /**
     * 에반 드래곤 장비 정보 (에반인 경우 응답)
     */
    dragonEquipment;
    /**
     * 메카닉 장비 정보 (메카닉인 경우 응답)
     */
    mechanicEquipment;
    constructor(obj) {
        const { date, character_gender, character_class, item_equipment, title, dragon_equipment, mechanic_equipment, } = obj;
        this.date = new Date(date);
        this.characterGender = character_gender;
        this.characterClass = character_class;
        this.itemEquipment = item_equipment.map((equipment) => new CharacterItemEquipmentInfoDto(equipment));
        this.title = new CharacterItemEquipmentTitleDto(title);
        this.dragonEquipment = dragon_equipment
            ? dragon_equipment.map((equipment) => new CharacterItemEquipmentInfoDto(equipment))
            : undefined;
        this.mechanicEquipment = mechanic_equipment
            ? mechanic_equipment.map((equipment) => new CharacterItemEquipmentInfoDto(equipment))
            : undefined;
    }
}

/**
 * 캐릭터 링크 스킬 정보
 */
class CharacterLinkSkillInfoDto {
    /**
     * 스킬 명
     */
    skillName;
    /**
     * 스킬 설명
     */
    skillDescription;
    /**
     * 스킬 레벨
     */
    skillLevel;
    /**
     * 스킬 효과
     */
    skillEffect;
    /**
     * 스킬 아이콘
     */
    skillIcon;
    constructor(obj) {
        const { skill_name, skill_description, skill_level, skill_effect, skill_icon, } = obj;
        this.skillName = skill_name;
        this.skillDescription = skill_description;
        this.skillLevel = skill_level;
        this.skillEffect = skill_effect;
        this.skillIcon = skill_icon;
    }
}

/**
 * 캐릭터 링크 스킬 정보
 */
class CharacterLinkSkillDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * 링크 스킬 정보
     */
    characterLinkSkill;
    /**
     * 내 링크 스킬 정보
     */
    characterOwnedLinkSkill;
    constructor(obj) {
        const { date, character_class, character_link_skill, character_owned_link_skill, } = obj;
        this.date = new Date(date);
        this.characterClass = character_class;
        this.characterLinkSkill = new CharacterLinkSkillInfoDto(character_link_skill);
        this.characterOwnedLinkSkill = new CharacterLinkSkillInfoDto(character_owned_link_skill);
    }
}

/**
 * 캐릭터 펫 장비 자동 스킬 정보
 */
class CharacterPetEquipmentAutoSkillDto {
    /**
     * 첫 번째 슬롯에 등록된 자동 스킬
     */
    skill1;
    /**
     * 첫 번째 슬롯에 등록된 자동 아이콘
     */
    skill1Icon;
    /**
     * 두 번째 슬롯에 등록된 자동 스킬
     */
    skill2;
    /**
     * 두 번째 슬롯에 등록된 자동 아이콘
     */
    skill2Icon;
    constructor(obj) {
        const { skill_1, skill_1_icon, skill_2, skill_2_icon } = obj;
        this.skill1 = skill_1;
        this.skill1Icon = skill_1_icon;
        this.skill2 = skill_2;
        this.skill2Icon = skill_2_icon;
    }
}

/**
 * 캐릭터 펫 장비 아이템 옵션 정보
 */
class CharacterPetEquipmentItemOptionDto {
    /**
     * 옵션 정보
     */
    optionType;
    /**
     * 옵션 값
     */
    optionValue;
    constructor(obj) {
        const { option_type, option_value } = obj;
        this.optionType = option_type;
        this.optionValue = option_value;
    }
}

/**
 * 캐릭터 펫 장비 아이템 정보
 */
class CharacterPetEquipmentItemDto {
    /**
     * 아이템 명
     */
    itemName;
    /**
     * 아이템 아이콘
     */
    itemIcon;
    /**
     * 아이템 설명
     */
    itemDescription;
    /**
     * 아이템 표기상 옵션
     */
    itemOption;
    /**
     * 업그레이드 횟수
     */
    scrollUpgrade;
    /**
     * 업그레이드 가능 횟수
     */
    scrollUpgradeable;
    constructor(obj) {
        const { item_name, item_icon, item_description, item_option, scroll_upgrade, scroll_upgradeable, } = obj;
        this.itemName = item_name;
        this.itemIcon = item_icon;
        this.itemDescription = item_description;
        this.itemOption = item_option.map((option) => new CharacterPetEquipmentItemOptionDto(option));
        this.scrollUpgrade = scroll_upgrade;
        this.scrollUpgradeable = scroll_upgradeable;
    }
}

/**
 * 캐릭터 펫 장비 정보
 */
class CharacterPetEquipmentDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 펫1 명
     */
    pet1Name;
    /**
     * 펫1 닉네임
     */
    pet1Nickname;
    /**
     * 펫1 아이콘
     */
    pet1Icon;
    /**
     * 펫1 설명
     */
    pet1Description;
    /**
     * 펫1 장착 정보
     */
    pet1Equipment;
    /**
     * 펫1 펫 버프 자동스킬 정보
     */
    pet1AutoSkill;
    /**
     * 펫1 원더 펫 종류
     */
    pet1PetType;
    /**
     * 펫1 펫 보유 스킬
     */
    pet1Skill;
    /**
     * 펫1 마법의 시간 (KST, 시간 단위 데이터로 분은 일괄 0으로 표기)
     */
    pet1DateExpire;
    /**
     * 펫2 명
     */
    pet2Name;
    /**
     * 펫2 닉네임
     */
    pet2Nickname;
    /**
     * 펫2 아이콘
     */
    pet2Icon;
    /**
     * 펫2 설명
     */
    pet2Description;
    /**
     * 펫2 장착 정보
     */
    pet2Equipment;
    /**
     * 펫2 펫 버프 자동스킬 정보
     */
    pet2AutoSkill;
    /**
     * 펫2 원더 펫 종류
     */
    pet2PetType;
    /**
     * 펫2 펫 보유 스킬
     */
    pet2Skill;
    /*
     * 펫2 마법의 시간 (KST, 시간 단위 데이터로 분은 일괄 0으로 표기)
     */
    pet2DateExpire;
    /**
     * 펫3 명
     */
    pet3Name;
    /**
     * 펫3 닉네임
     */
    pet3Nickname;
    /**
     * 펫3 아이콘
     */
    pet3Icon;
    /**
     * 펫3 설명
     */
    pet3Description;
    /**
     * 펫3 장착 정보
     */
    pet3Equipment;
    /**
     * 펫3 펫 버프 자동스킬 정보
     */
    pet3AutoSkill;
    /**
     * 펫3 원더 펫 종류
     */
    pet3PetType;
    /**
     * 펫3 펫 보유 스킬
     */
    pet3Skill;
    /*
     * 펫3 마법의 시간 (KST, 시간 단위 데이터로 분은 일괄 0으로 표기)
     */
    pet3DateExpire;
    constructor(obj) {
        const { date, pet_1_name, pet_1_nickname, pet_1_icon, pet_1_description, pet_1_equipment, pet_1_auto_skill, pet_1_pet_type, pet_1_skill, pet_1_date_expire, pet_2_name, pet_2_nickname, pet_2_icon, pet_2_description, pet_2_equipment, pet_2_auto_skill, pet_2_pet_type, pet_2_skill, pet_2_date_expire, pet_3_name, pet_3_nickname, pet_3_icon, pet_3_description, pet_3_equipment, pet_3_auto_skill, pet_3_pet_type, pet_3_skill, pet_3_date_expire, } = obj;
        this.date = new Date(date);
        this.pet1Name = pet_1_name;
        this.pet1Nickname = pet_1_nickname;
        this.pet1Icon = pet_1_icon;
        this.pet1Description = pet_1_description;
        this.pet1Equipment = new CharacterPetEquipmentItemDto(pet_1_equipment);
        this.pet1AutoSkill = new CharacterPetEquipmentAutoSkillDto(pet_1_auto_skill);
        this.pet1PetType = pet_1_pet_type;
        this.pet1Skill = pet_1_skill;
        this.pet1DateExpire = new Date(pet_1_date_expire);
        this.pet2Name = pet_2_name;
        this.pet2Nickname = pet_2_nickname;
        this.pet2Icon = pet_2_icon;
        this.pet2Description = pet_2_description;
        this.pet2Equipment = new CharacterPetEquipmentItemDto(pet_2_equipment);
        this.pet2AutoSkill = new CharacterPetEquipmentAutoSkillDto(pet_2_auto_skill);
        this.pet2PetType = pet_2_pet_type;
        this.pet2Skill = pet_2_skill;
        this.pet2DateExpire = new Date(pet_2_date_expire);
        this.pet3Name = pet_3_name;
        this.pet3Nickname = pet_3_nickname;
        this.pet3Icon = pet_3_icon;
        this.pet3Description = pet_3_description;
        this.pet3Equipment = new CharacterPetEquipmentItemDto(pet_3_equipment);
        this.pet3AutoSkill = new CharacterPetEquipmentAutoSkillDto(pet_3_auto_skill);
        this.pet3PetType = pet_3_pet_type;
        this.pet3Skill = pet_3_skill;
        this.pet3DateExpire = new Date(pet_3_date_expire);
    }
}

/**
 * 캐릭터 인기도 정보
 */
class CharacterPopularityDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 인기도
     */
    popularity;
    constructor(obj) {
        const { date, popularity } = obj;
        this.date = new Date(date);
        this.popularity = popularity;
    }
}

/**
 * 캐릭터 성향 정보
 */
class CharacterPropensityDto {
    date;
    /**
     * 카리스마 레벨
     */
    charismaLevel;
    /**
     * 감성 레벨
     */
    sensibilityLevel;
    /**
     * 통찰력 레벨
     */
    insightLevel;
    /**
     *  의지 레벨
     */
    willingnessLevel;
    /**
     * 손재주 레벨
     */
    handicraftLevel;
    /**
     * 매력 레벨
     */
    charmLevel;
    constructor(obj) {
        const { date, charisma_level, sensibility_level, insight_level, willingness_level, handicraft_level, charm_level, } = obj;
        this.date = new Date(date);
        this.charismaLevel = charisma_level;
        this.sensibilityLevel = sensibility_level;
        this.insightLevel = insight_level;
        this.willingnessLevel = willingness_level;
        this.handicraftLevel = handicraft_level;
        this.charmLevel = charm_level;
    }
}

/**
 * 캐릭터 세트 효과 옵션 정보
 */
class CharacterSetEffectOptionInfoDto {
    /**
     * 세트 효과 레벨 (장비 수)
     */
    setCount;
    /**
     * 적용 중인 세트 효과
     */
    setOption;
    constructor(obj) {
        const { set_count, set_option } = obj;
        this.setCount = set_count;
        this.setOption = set_option;
    }
}

/**
 * 캐릭터 세트 효과 정보
 */
class CharacterSetEffectInfoDto {
    /**
     * 세트 효과 명
     */
    setName;
    /**
     * 세트 개수 (럭키 아이템 포함)
     */
    totalSetCount;
    /**
     * 세트 효과 옵션
     */
    setEffectInfo;
    constructor(obj) {
        const { set_name, total_set_count, set_effect_info } = obj;
        this.setName = set_name;
        this.totalSetCount = total_set_count;
        this.setEffectInfo = set_effect_info.map((info) => new CharacterSetEffectOptionInfoDto(info));
    }
}

/**
 * 캐릭터 세트 효과 정보
 */
class CharacterSetEffectDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 세트 효과 정보
     */
    setEffect;
    constructor(obj) {
        const { date, set_effect } = obj;
        this.date = new Date(date);
        this.setEffect = set_effect.map((effect) => new CharacterSetEffectInfoDto(effect));
    }
}

/**
 * 캐릭터 스킬 상세 정보
 */
class CharacterSkillInfoDto {
    /**
     * 스킬 명
     */
    skillName;
    /**
     * 스킬 설명
     */
    skillDescription;
    /**
     * 스킬 레벨
     */
    skillLevel;
    /**
     * 스킬 레벨 별 효과 설명
     */
    skillEffect;
    /**
     * 스킬 아이콘
     */
    skillIcon;
    constructor(obj) {
        const { skill_name, skill_description, skill_level, skill_effect, skill_icon, } = obj;
        this.skillName = skill_name;
        this.skillDescription = skill_description;
        this.skillLevel = skill_level;
        this.skillEffect = skill_effect;
        this.skillIcon = skill_icon;
    }
}

/**
 * 캐릭터 스킬 정보
 */
class CharacterSkillDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * 스킬 전직 차수
     */
    characterSkillGrade;
    /**
     * 스킬 정보
     */
    characterSkill;
    constructor(obj) {
        const { date, character_class, character_skill_grade, character_skill } = obj;
        this.date = new Date(date);
        this.characterClass = character_class;
        this.characterSkillGrade = character_skill_grade;
        this.characterSkill = character_skill.map((skill) => new CharacterSkillInfoDto(skill));
    }
}

/**
 * 캐릭터 스탯 정보
 */
class CharacterStatDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * 현재 스탯 정보
     */
    finalStat;
    /**
     * 잔여 AP
     */
    remainAP;
    constructor(obj) {
        const { date, character_class, final_stat, remain_ap } = obj;
        this.date = new Date(date);
        this.characterClass = character_class;
        this.finalStat = final_stat.map((stat) => {
            return {
                statName: stat.stat_name,
                statValue: stat.stat_value,
            };
        });
        this.remainAP = remain_ap;
    }
}

/**
 * 캐릭터 심볼 상세 정보
 */
class CharacterSymbolEquipmentInfoDto {
    /**
     * 심볼 명
     */
    symbolName;
    /**
     * 심볼 아이콘
     */
    symbolIcon;
    /**
     * 심볼 설명
     */
    symbolDescription;
    /**
     * 심볼로 인한 증가 수치
     */
    symbolForce;
    /**
     * 심볼 레벨
     */
    symbolLevel;
    /**
     * 심볼로 증가한 힘
     */
    symbolStr;
    /**
     * 심볼로 증가한 민첩
     */
    symbolDex;
    /**
     * 심볼로 증가한 지력
     */
    symbolInt;
    /**
     * 심볼로 증가한 운
     */
    symbolLuk;
    /**
     * 심볼로 증가한 체력
     */
    symbolHp;
    /**
     * 현재 보유 성장치
     */
    symbolGrowthCount;
    /**
     * 성장 시 필요한 성장치
     */
    symbolRequireGrowthCount;
    constructor(obj) {
        const { symbol_name, symbol_icon, symbol_description, symbol_force, symbol_level, symbol_str, symbol_dex, symbol_int, symbol_luk, symbol_hp, symbol_growth_count, symbol_require_growth_count, } = obj;
        this.symbolName = symbol_name;
        this.symbolIcon = symbol_icon;
        this.symbolDescription = symbol_description;
        this.symbolForce = symbol_force;
        this.symbolLevel = symbol_level;
        this.symbolStr = symbol_str;
        this.symbolDex = symbol_dex;
        this.symbolInt = symbol_int;
        this.symbolLuk = symbol_luk;
        this.symbolHp = symbol_hp;
        this.symbolGrowthCount = symbol_growth_count;
        this.symbolRequireGrowthCount = symbol_require_growth_count;
    }
}

/**
 * 캐릭터 심볼 정보
 */
class CharacterSymbolEquipmentDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * 심볼 정보
     */
    symbol;
    constructor(obj) {
        const { date, character_class, symbol } = obj;
        this.date = new Date(date);
        this.characterClass = character_class;
        this.symbol = symbol.map((s) => new CharacterSymbolEquipmentInfoDto(s));
    }
}

/**
 * 캐릭터 V코어 정보
 */
class CharacterVMatrixCodeEquipmentDto {
    /**
     * 슬롯 인덱스
     */
    slotId;
    /**
     * 슬롯 레벨
     */
    slotLevel;
    /**
     * 코어 명
     */
    vCoreName;
    /**
     * 코어 타입
     */
    vCoreType;
    /**
     * 코어 레벨
     */
    vCoreLevel;
    /**
     * 코어에 해당하는 스킬 명
     */
    vCoreSkill1;
    /**
     * (강화 코어인 경우) 코어에 해당하는 두 번째 스킬 명
     */
    vCoreSkill2;
    /**
     * (강화 코어인 경우) 코어에 해당하는 세 번째 스킬 명
     */
    vCoreSkill3;
    constructor(obj) {
        const { slot_id, slot_level, v_core_name, v_core_type, v_core_level, v_core_skill_1, v_core_skill_2, v_core_skill_3, } = obj;
        this.slotId = slot_id;
        this.slotLevel = slot_level;
        this.vCoreName = v_core_name;
        this.vCoreType = v_core_type;
        this.vCoreLevel = v_core_level;
        this.vCoreSkill1 = v_core_skill_1;
        this.vCoreSkill2 = v_core_skill_2;
        this.vCoreSkill3 = v_core_skill_3;
    }
}

/**
 * 캐릭터 V매트릭스 정보
 */
class CharacterVMatrixDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 캐릭터 직업
     */
    characterClass;
    /**
     * V코어 정보
     */
    characterVCoreEquipment;
    /**
     * 캐릭터 잔여 매트릭스 강화 포인트
     */
    characterVMatrixRemainSlotUpgradePoint;
    constructor(obj) {
        const { date, character_class, character_v_core_equipment, character_v_matrix_remain_slot_upgrade_point, } = obj;
        this.date = new Date(date);
        this.characterClass = character_class;
        this.characterVCoreEquipment = character_v_core_equipment.map((equipment) => new CharacterVMatrixCodeEquipmentDto(equipment));
        this.characterVMatrixRemainSlotUpgradePoint =
            character_v_matrix_remain_slot_upgrade_point;
    }
}

var PotentialOptionGrade;
(function (PotentialOptionGrade) {
    PotentialOptionGrade[PotentialOptionGrade["RARE"] = 0] = "RARE";
    PotentialOptionGrade[PotentialOptionGrade["EPIC"] = 1] = "EPIC";
    PotentialOptionGrade[PotentialOptionGrade["UNIQUE"] = 2] = "UNIQUE";
    PotentialOptionGrade[PotentialOptionGrade["LEGENDARY"] = 3] = "LEGENDARY";
})(PotentialOptionGrade || (PotentialOptionGrade = {}));
/**
 * 한글로 정의된 잠재옵션 등급을 PotentialOptionGrade으로 변환합니다.
 *
 * @param text support only "레어", "에픽", "유니크", "레전드리"
 */
const potentialOptionGradeFromString = (text) => {
    const potentialOptionGradeMap = {
        레어: PotentialOptionGrade.RARE,
        에픽: PotentialOptionGrade.EPIC,
        유니크: PotentialOptionGrade.UNIQUE,
        레전드리: PotentialOptionGrade.LEGENDARY,
    };
    const grade = potentialOptionGradeMap[text];
    if (!grade) {
        throw new TypeError('No enum constant for string: ' + text);
    }
    return grade;
};

/**
 * 큐브 결과 옵션 정보
 */
class CubeResultOptionDto {
    /**
     * 옵션 명
     */
    value;
    /**
     * 옵션 등급
     */
    grade;
    constructor(obj) {
        const { value, grade } = obj;
        this.value = value;
        this.grade = grade;
    }
    get gradeEnum() {
        return potentialOptionGradeFromString(this.grade);
    }
}

/**
 * 큐브 히스토리
 */
class CubeHistoryDto {
    /**
     * 큐브 히스토리 식별자
     */
    id;
    /**
     * 캐릭터 명
     */
    characterName;
    /**
     * 월드 명
     */
    worldName;
    /**
     * 사용 일시
     */
    dateCreate;
    /**
     * 사용 큐브
     */
    cubeType;
    /**
     * 사용 결과
     */
    itemUpgradeResult;
    /**
     * 미라클 타임 적용 여부
     */
    miracleTimeFlag;
    /**
     * 장비 분류
     */
    itemEquipmentPart;
    /**
     * 장비 레벨
     */
    itemLevel;
    /**
     * 큐브 사용한 장비
     */
    targetItem;
    /**
     * 잠재능력 등급
     */
    potentialOptionGrade;
    /**
     * 에디셔널 잠재능력 등급
     */
    additionalPotentialOptionGrade;
    /**
     * 천장에 도달하여 확정 등급 상승한 여부
     */
    upgradeGuarantee;
    /**
     * 현재까지 쌓은 스택
     */
    upgradeGuaranteeCount;
    /**
     * 사용 전 잠재능력 옵션
     */
    beforePotentialOption;
    /**
     * 사용 전 에디셔널 잠재능력 옵션
     */
    beforeAdditionalPotentialOption;
    /**
     * 사용 후 잠재능력 옵션
     */
    afterPotentialOption;
    /**
     * 사용 후 에디셔널 잠재능력 옵션
     */
    afterAdditionalPotentialOption;
    constructor(obj) {
        const { id, character_name, world_name, date_create, cube_type, item_upgrade_result, miracle_time_flag, item_equipment_part, item_level, target_item, potential_option_grade, additional_potential_option_grade, upgrade_guarantee, upgrade_guarantee_count, before_potential_option, before_additional_potential_option, after_potential_option, after_additional_potential_option, } = obj;
        this.id = id;
        this.characterName = character_name;
        this.worldName = world_name;
        this.dateCreate = new Date(date_create);
        this.cubeType = cube_type;
        this.itemUpgradeResult = item_upgrade_result;
        this.miracleTimeFlag = miracle_time_flag;
        this.itemEquipmentPart = item_equipment_part;
        this.itemLevel = item_level;
        this.targetItem = target_item;
        this.potentialOptionGrade = potential_option_grade;
        this.additionalPotentialOptionGrade = additional_potential_option_grade;
        this.upgradeGuarantee = upgrade_guarantee;
        this.upgradeGuaranteeCount = upgrade_guarantee_count;
        this.beforePotentialOption = before_potential_option.map((origin) => new CubeResultOptionDto(origin));
        this.beforeAdditionalPotentialOption =
            before_additional_potential_option.map((origin) => new CubeResultOptionDto(origin));
        this.afterPotentialOption = after_potential_option.map((origin) => new CubeResultOptionDto(origin));
        this.afterAdditionalPotentialOption = after_additional_potential_option.map((origin) => new CubeResultOptionDto(origin));
    }
    get isItemUpgrade() {
        return this.itemUpgradeResult === '성공';
    }
    get isMiracleTimeFlag() {
        return this.miracleTimeFlag !== '이벤트 적용되지 않음';
    }
    get potentialOptionGradeEnum() {
        return potentialOptionGradeFromString(this.potentialOptionGrade);
    }
    get additionalPotentialOptionGradeEnum() {
        return potentialOptionGradeFromString(this.additionalPotentialOptionGrade);
    }
}

/**
 * 큐브 히스토리 응답 정보
 */
class CubeHistoryResponseDto {
    /**
     * 결과 건 수
     */
    count;
    /**
     * 큐브 히스토리
     */
    cubeHistory;
    /**
     * 페이징 처리를 위한 cursor
     */
    nextCursor;
    constructor(obj) {
        const { count, cube_history, next_cursor } = obj;
        this.count = count;
        this.cubeHistory = cube_history.map((origin) => new CubeHistoryDto(origin));
        this.nextCursor = next_cursor;
    }
}

/**
 * 무릉도장 랭킹 정보
 */
class DojangRankingDto {
    /**
     * 랭킹 업데이트 일자 (KST, 일 단위 데이터로 시, 분은 일괄 0으로 표기)
     */
    date;
    /**
     * 무릉도장 랭킹 순위
     */
    ranking;
    /**
     * 캐릭터 명
     */
    characterName;
    /**
     * 월드 명
     */
    worldName;
    /**
     * 직업 명
     */
    className;
    /**
     * 전직 직업 명
     */
    subClassName;
    /**
     * 캐릭터 레벨
     */
    characterLevel;
    /**
     * 무릉도장 구간
     */
    dojangFloor;
    /**
     * 무릉도장 클리어 시간 기록 (초 단위)
     */
    dojangTimeRecord;
    constructor(obj) {
        const { date, ranking, character_name, world_name, class_name, sub_class_name, character_level, dojang_floor, dojang_time_record, } = obj;
        this.date = new Date(date);
        this.ranking = ranking;
        this.characterName = character_name;
        this.worldName = world_name;
        this.className = class_name;
        this.subClassName = sub_class_name;
        this.characterLevel = character_level;
        this.dojangFloor = dojang_floor;
        this.dojangTimeRecord = dojang_time_record;
    }
}

/**
 * 무릉도장 랭킹 응답 정보
 */
class DojangRankingResponseDto {
    /**
     * 길드 랭킹 정보
     */
    ranking;
    constructor(obj) {
        const { ranking } = obj;
        this.ranking = ranking.map((rank) => new DojangRankingDto(rank));
    }
}

/**
 * 길드 스킬 정보
 */
class GuildSkillDto {
    /**
     * 스킬 명
     */
    skillName;
    /**
     * 스킬 설명
     */
    skillDescription;
    /**
     * 스킬 레벨
     */
    skillLevel;
    /**
     * 스킬 레벨 별 효과
     */
    skillEffect;
    /**
     * 스킬 아이콘
     */
    skillIcon;
    constructor(obj) {
        const { skill_name, skill_description, skill_level, skill_effect, skill_icon, } = obj;
        this.skillName = skill_name;
        this.skillDescription = skill_description;
        this.skillLevel = skill_level;
        this.skillEffect = skill_effect;
        this.skillIcon = skill_icon;
    }
}

/**
 * 길드 기본 정보
 */
class GuildBasicDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 월드 명
     */
    worldName;
    /**
     * 길드 명
     */
    guildName;
    /**
     * 길드 레벨
     */
    guildLevel;
    /**
     * 길드 명성치
     */
    guildFame;
    /**
     * 길드 포인트(GP)
     */
    guildPoint;
    /**
     * 길드 마스터 캐릭터 명
     */
    guildMasterName;
    /**
     * 길드원 수
     */
    guildMemberCount;
    /**
     * 길드원 목록
     */
    guildMember;
    /**
     * 길드 스킬 목록
     */
    guildSkill;
    /**
     * 노블레스 스킬 목록
     */
    guildNoblesseSkill;
    /**
     * 조합형 길드 마크
     */
    guildMark;
    /**
     * 커스텀 길드 마크 (base64 인코딩 형식)
     */
    guildMarkCustom;
    constructor(obj) {
        const { date, world_name, guild_name, guild_level, guild_fame, guild_point, guild_master_name, guild_member_count, guild_member, guild_skill, guild_noblesse_skill, guild_mark, guild_mark_custom, } = obj;
        this.date = new Date(date);
        this.worldName = world_name;
        this.guildName = guild_name;
        this.guildLevel = guild_level;
        this.guildFame = guild_fame;
        this.guildPoint = guild_point;
        this.guildMasterName = guild_master_name;
        this.guildMemberCount = guild_member_count;
        this.guildMember = guild_member;
        this.guildSkill = guild_skill.map((skill) => new GuildSkillDto(skill));
        this.guildNoblesseSkill = guild_noblesse_skill.map((skill) => new GuildSkillDto(skill));
        this.guildMark = guild_mark;
        this.guildMarkCustom = guild_mark_custom;
    }
}

/**
 * 길드 식별자 정보
 */
class GuildDto {
    /**
     * 길드 식별자
     */
    oguildId;
    constructor(obj) {
        const { oguild_id } = obj;
        this.oguildId = oguild_id;
    }
}

/**
 * 길드 랭킹 정보
 */
class GuildRankingDto {
    /**
     * 랭킹 업데이트 일자 (KST, 일 단위 데이터로 시, 분은 일괄 0으로 표기)
     */
    date;
    /**
     * 길드 랭킹 순위
     */
    ranking;
    /**
     * 길드 명
     */
    guildName;
    /**
     * 월드 명
     */
    worldName;
    /**
     * 길드 레벨
     */
    guildLevel;
    /**
     * 길드 마스터 캐릭터 명
     */
    guildMasterName;
    /**
     * 길드 마크
     */
    guildMark;
    /**
     * 길드 포인트
     */
    guildPoint;
    constructor(obj) {
        const { date, ranking, guild_name, world_name, guild_level, guild_master_name, guild_mark, guild_point, } = obj;
        this.date = new Date(date);
        this.ranking = ranking;
        this.guildName = guild_name;
        this.worldName = world_name;
        this.guildLevel = guild_level;
        this.guildMasterName = guild_master_name;
        this.guildMark = guild_mark;
        this.guildPoint = guild_point;
    }
}

/**
 * 길드 랭킹 응답 정보
 */
class GuildRankingResponseDto {
    /**
     * 길드 랭킹 정보
     */
    ranking;
    constructor(obj) {
        const { ranking } = obj;
        this.ranking = ranking.map((rank) => new GuildRankingDto(rank));
    }
}

/**
 * 서버 점검 정보
 */
class InspectionInfoDto {
    /**
     * 서비스 코드
     */
    serviceCode;
    /**
     * 점검 시작 시각
     */
    startDateTime;
    /**
     * 점검 종료 시각
     */
    endDateTime;
    /**
     * 점검 안내 제목
     */
    strObstacleContents;
    constructor(obj) {
        const inspectionInfoTag = obj['soap:Envelope']['soap:Body'][0]['GetInspectionInfoResponse'][0]['GetInspectionInfoResult'][0]['diffgr:diffgram'][0]['NewDataSet'][0]['InspectionInfo'][0];
        this.serviceCode = Number(inspectionInfoTag.serviceCode[0]);
        this.startDateTime = new Date(inspectionInfoTag.startDateTime[0]);
        this.endDateTime = new Date(inspectionInfoTag.endDateTime[0]);
        this.strObstacleContents = inspectionInfoTag.strObstacleContents[0];
    }
}

/**
 * 종합 랭킹 정보
 */
class OverallRankingDto {
    /**
     * 랭킹 업데이트 일자 (KST, 일 단위 데이터로 시, 분은 일괄 0으로 표기)
     */
    date;
    /**
     * 종합 랭킹 순위
     */
    ranking;
    /**
     * 캐릭터 명
     */
    characterName;
    /**
     * 월드 명
     */
    worldName;
    /**
     * 직업 명
     */
    className;
    /**
     * 전직 직업 명
     */
    subClassName;
    /**
     * 캐릭터 레벨
     */
    characterLevel;
    /**
     * 캐릭터 경험치
     */
    characterExp;
    /**
     * 캐릭터 인기도
     */
    characterPopularity;
    /**
     * 길드 명
     */
    characterGuildName;
    constructor(obj) {
        const { date, ranking, character_name, world_name, class_name, sub_class_name, character_level, character_exp, character_popularity, character_guildname, } = obj;
        this.date = new Date(date);
        this.ranking = ranking;
        this.characterName = character_name;
        this.worldName = world_name;
        this.className = class_name;
        this.subClassName = sub_class_name;
        this.characterLevel = character_level;
        this.characterExp = character_exp;
        this.characterPopularity = character_popularity;
        this.characterGuildName = character_guildname;
    }
}

/**
 * 종합 랭킹 응답 정보
 */
class OverallRankingResponseDto {
    /**
     * 종합 랭킹 정보
     */
    ranking;
    constructor(obj) {
        const { ranking } = obj;
        this.ranking = ranking.map((rank) => new OverallRankingDto(rank));
    }
}

/**
 * 더 시드 랭킹 정보
 */
class TheSeedRankingDto {
    /**
     * 랭킹 업데이트 일자 (KST, 일 단위 데이터로 시, 분은 일괄 0으로 표기)
     */
    date;
    /**
     * 더 시드 랭킹 순위
     */
    ranking;
    /**
     * 캐릭터 명
     */
    characterName;
    /**
     * 월드 명
     */
    worldName;
    /**
     * 직업 명
     */
    className;
    /**
     * 전직 직업 명
     */
    subClassName;
    /**
     * 캐릭터 레벨
     */
    characterLevel;
    /**
     * 더 시드 도달 층
     */
    theSeedFloor;
    /**
     * 더 시드 클리어 시간 기록 (초 단위)
     */
    theSeedTimeRecord;
    constructor(obj) {
        const { date, ranking, character_name, world_name, class_name, sub_class_name, character_level, theseed_floor, theseed_time_record, } = obj;
        this.date = new Date(date);
        this.ranking = ranking;
        this.characterName = character_name;
        this.worldName = world_name;
        this.className = class_name;
        this.subClassName = sub_class_name;
        this.characterLevel = character_level;
        this.theSeedFloor = theseed_floor;
        this.theSeedTimeRecord = theseed_time_record;
    }
}

/**
 * 더 시드 랭킹 응답 정보
 */
class TheSeedRankingResponseDto {
    /**
     * 더 시드 랭킹 정보
     */
    ranking;
    constructor(obj) {
        const { ranking } = obj;
        this.ranking = ranking.map((rank) => new TheSeedRankingDto(rank));
    }
}

/**
 * 유니온 정보
 */
class UnionDto {
    /**
     * 조회 기준일
     */
    date;
    /**
     * 유니온 레벨
     */
    unionLevel;
    /**
     * 유니온 등급
     */
    unionGrade;
    constructor(obj) {
        const { date, union_level, union_grade } = obj;
        this.date = new Date(date);
        this.unionLevel = union_level;
        this.unionGrade = union_grade;
    }
}

/**
 * 유니온 블록이 차지하고 있는 영역 좌표들
 */
class UnionRaiderBlockPositionDto {
    /**
     * 블록 X좌표
     */
    x;
    /**
     * 블록 Y좌표
     */
    y;
    constructor(obj) {
        const { x, y } = obj;
        this.x = x;
        this.y = y;
    }
}

/**
 * 유니온 블록 기준점 좌표 정보
 */
class UnionRaiderBlockControlPointDto {
    /**
     * 블록 기준점 X좌표
     */
    x;
    /**
     * 블록 기준점 Y좌표
     */
    y;
    constructor(obj) {
        const { x, y } = obj;
        this.x = x;
        this.y = y;
    }
}

/**
 * 유니온 블록 정보
 */
class UnionRaiderBlockDto {
    /**
     * 블록 모양 (전사, 마법사, 궁수, 도적, 해적, 메이플m, 하이브리드)
     */
    blockType;
    /**
     * 블록 해당 캐릭터 직업
     */
    blockClass;
    /**
     * 블록 해당 캐릭터 레벨
     */
    blockLevel;
    /**
     * 블록 기준점 좌표
     */
    blockControlPoint;
    /**
     * 블록이 차지하고 있는 영역 좌표들 (null:미 배치 시)
     */
    blockPosition;
    constructor(obj) {
        const { block_type, block_class, block_level, block_control_point, block_position, } = obj;
        this.blockType = block_type;
        this.blockClass = block_class;
        this.blockLevel = block_level;
        this.blockControlPoint = new UnionRaiderBlockControlPointDto(block_control_point);
        this.blockPosition = block_position
            ? block_position.map((position) => new UnionRaiderBlockPositionDto(position))
            : null;
    }
}

/**
 * 유니온 공격대 배치 정보
 */
class UnionRaiderInnerStatDto {
    /**
     * 공격대 배치 위치 (11시 방향부터 시계 방향 순서대로 0~7)
     */
    statFieldId;
    /**
     * 해당 지역 점령 효과
     */
    statFieldEffect;
    constructor(obj) {
        const { stat_field_id, stat_field_effect } = obj;
        this.statFieldId = stat_field_id;
        this.statFieldEffect = stat_field_effect;
    }
}

/**
 * 유니온 공격대 정보
 */
class UnionRaiderDto {
    date;
    /**
     * 유니온 공격대원 효과
     */
    unionRaiderStat;
    /**
     * 유니온 공격대 점령 효과
     */
    unionOccupiedStat;
    /**
     * 유니온 공격대 배치
     */
    unionInnerStat;
    /**
     * 유니온 블록 정보
     */
    unionBlock;
    constructor(obj) {
        const { date, union_raider_stat, union_occupied_stat, union_inner_stat, union_block, } = obj;
        this.date = new Date(date);
        this.unionRaiderStat = union_raider_stat;
        this.unionOccupiedStat = union_occupied_stat;
        this.unionInnerStat = union_inner_stat.map((stat) => new UnionRaiderInnerStatDto(stat));
        this.unionBlock = union_block.map((block) => new UnionRaiderBlockDto(block));
    }
}

/**
 * 유니온 랭킹 정보
 */
class UnionRankingDto {
    /**
     * 랭킹 업데이트 일자 (KST, 일 단위 데이터로 시, 분은 일괄 0으로 표기)
     */
    date;
    /**
     * 유니온 랭킹 순위
     */
    ranking;
    /**
     * 캐릭터 명
     */
    characterName;
    /**
     * 월드 명
     */
    worldName;
    /**
     * 직업 명
     */
    className;
    /**
     * 전직 직업 명
     */
    subClassName;
    /**
     * 유니온 레벨
     */
    unionLevel;
    /**
     * 유니온 파워
     */
    unionPower;
    constructor(obj) {
        const { date, ranking, character_name, world_name, class_name, sub_class_name, union_level, union_power, } = obj;
        this.date = new Date(date);
        this.ranking = ranking;
        this.characterName = character_name;
        this.worldName = world_name;
        this.className = class_name;
        this.subClassName = sub_class_name;
        this.unionLevel = union_level;
        this.unionPower = union_power;
    }
}

/**
 * 유니온 랭킹 응답 정보
 */
class UnionRankingResponseDto {
    /**
     * 유니온 랭킹 정보
     */
    ranking;
    constructor(obj) {
        const { ranking } = obj;
        this.ranking = ranking.map((rank) => new UnionRankingDto(rank));
    }
}

/**
 * MapleStory OpenAPI error.<br>
 * Please refer to <a href="https://openapi.nexon.com/guide/request-api/">MapleStory API guide</a> for the error details.
 */
class MapleStoryApiError extends Error {
    name = 'MapleStoryApiError';
    errorCode;
    message;
    constructor(errorBody) {
        const { name, message } = errorBody.error;
        super(message);
        this.errorCode = errorMap[name];
        this.message = message;
    }
}
/**
 * MapleStory OpenAPI error codes.<br>
 * Please refer to <a href="https://openapi.nexon.com/guide/request-api/">MapleStory API guide</a> for the error code details.
 */
var MapleStoryApiErrorCode;
(function (MapleStoryApiErrorCode) {
    MapleStoryApiErrorCode[MapleStoryApiErrorCode["OPENAPI00001"] = 0] = "OPENAPI00001";
    MapleStoryApiErrorCode[MapleStoryApiErrorCode["OPENAPI00002"] = 1] = "OPENAPI00002";
    MapleStoryApiErrorCode[MapleStoryApiErrorCode["OPENAPI00003"] = 2] = "OPENAPI00003";
    MapleStoryApiErrorCode[MapleStoryApiErrorCode["OPENAPI00004"] = 3] = "OPENAPI00004";
    MapleStoryApiErrorCode[MapleStoryApiErrorCode["OPENAPI00005"] = 4] = "OPENAPI00005";
    MapleStoryApiErrorCode[MapleStoryApiErrorCode["OPENAPI00006"] = 5] = "OPENAPI00006";
    MapleStoryApiErrorCode[MapleStoryApiErrorCode["OPENAPI00007"] = 6] = "OPENAPI00007";
})(MapleStoryApiErrorCode || (MapleStoryApiErrorCode = {}));
const errorMap = {
    ['OPENAPI00001']: MapleStoryApiErrorCode.OPENAPI00001,
    ['OPENAPI00002']: MapleStoryApiErrorCode.OPENAPI00002,
    ['OPENAPI00003']: MapleStoryApiErrorCode.OPENAPI00003,
    ['OPENAPI00004']: MapleStoryApiErrorCode.OPENAPI00004,
    ['OPENAPI00005']: MapleStoryApiErrorCode.OPENAPI00005,
    ['OPENAPI00006']: MapleStoryApiErrorCode.OPENAPI00006,
    ['OPENAPI00007']: MapleStoryApiErrorCode.OPENAPI00007,
};

/**
 * 스타포스 강화 이벤트 정보
 */
class StarforceEventDto {
    /**
     * 이벤트 성공 확률
     */
    successRate;
    /**
     * 이벤트 비용 할인율
     */
    costDiscountRate;
    /**
     * 이벤트 강화 수치 가중값
     */
    plusValue;
    /**
     * 이벤트 적용 강화 시도 가능한 n성 범위
     */
    starforceEventRange;
    constructor(obj) {
        const { success_rate, cost_discount_rate, plus_value, starforce_event_range, } = obj;
        this.successRate = success_rate;
        this.costDiscountRate = cost_discount_rate;
        this.plusValue = plus_value;
        this.starforceEventRange = starforce_event_range;
    }
}

/**
 * 스타포스 히스토리
 */
class StarforceHistoryDto {
    /**
     *스타포스 히스토리 식별자
     */
    id;
    /**
     *강화 시도 결과
     */
    itemUpgradeResult;
    /**
     *강화 시도 전 스타포스 수치
     */
    beforeStarforceCount;
    /**
     *강화 시도 후 스타포스 수치
     */
    afterStarforceCount;
    /**
     *스타 캐치
     */
    starCatchResult;
    /**
     *슈페리얼 장비
     */
    superiorItemFlag;
    /**
     *파괴 방지
     */
    destroyDefence;
    /**
     *찬스 타임
     */
    chanceTime;
    /**
     *파괴 방지 필드 이벤트
     */
    eventFieldFlag;
    /**
     *사용 주문서 명
     */
    upgradeItem;
    /**
     *프로텍트 실드
     */
    protectShield;
    /**
     *보너스 스탯 부여 아이템 여부
     */
    bonusStatUpgrade;
    /**
     *캐릭터 명
     */
    characterName;
    /**
     *월드 명
     */
    worldName;
    /**
     *대상 장비 아이템 명
     */
    targetItem;
    /**
     *강화 일시 (KST)
     */
    dateCreate;
    /**
     * 진행 중인 스타포스 강화 이벤트 정보
     */
    starforceEventList;
    constructor(obj) {
        const { id, item_upgrade_result, before_starforce_count, after_starforce_count, starcatch_result, superior_item_flag, destroy_defence, chance_time, event_field_flag, upgrade_item, protect_shield, bonus_stat_upgrade, character_name, world_name, target_item, date_create, starforce_event_list, } = obj;
        this.id = id;
        this.itemUpgradeResult = item_upgrade_result;
        this.beforeStarforceCount = before_starforce_count;
        this.afterStarforceCount = after_starforce_count;
        this.starCatchResult = starcatch_result;
        this.superiorItemFlag = superior_item_flag;
        this.destroyDefence = destroy_defence;
        this.chanceTime = chance_time;
        this.eventFieldFlag = event_field_flag;
        this.upgradeItem = upgrade_item;
        this.protectShield = protect_shield;
        this.bonusStatUpgrade = bonus_stat_upgrade;
        this.characterName = character_name;
        this.worldName = world_name;
        this.targetItem = target_item;
        this.dateCreate = new Date(date_create);
        this.starforceEventList = starforce_event_list.map((event) => new StarforceEventDto(event));
    }
}

/**
 * 스타포스 히스토리 응답 정보
 */
class StarforceHistoryResponseDto {
    /**
     * 결과 건 수
     */
    count;
    /**
     * 스타포스 히스토리
     */
    starforceHistory;
    /**
     * 페이징 처리를 위한 cursor
     */
    nextCursor;
    constructor(obj) {
        const { count, starforce_history, next_cursor } = obj;
        this.count = count;
        this.starforceHistory = starforce_history.map((origin) => new StarforceHistoryDto(origin));
        this.nextCursor = next_cursor;
    }
}

dayjs.extend(timezone);
dayjs.extend(utc);
/**
 * MapleStory OpenAPI client.<br>
 * This is an implementation of <a href="https://openapi.nexon.com/game/maplestory">MapleStory API</a>
 */
class MapleStoryApi {
    apiKey;
    static BASE_URL = 'https://open.api.nexon.com/';
    static kstOffset = 540;
    timeout;
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.timeout = 5000;
    }
    //#region 캐릭터 정보 조회
    /**
     * 캐릭터 식별자(ocid)를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param characterName    캐릭터 명
     */
    async getCharacter(characterName) {
        try {
            const path = 'maplestory/v1/id';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: {
                    character_name: characterName,
                },
            });
            return new CharacterDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 기본 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterBasic(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/basic';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterBasicDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 인기도 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterPopularity(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/popularity';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterPopularityDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 종합 능력치 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterStat(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/stat';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterStatDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 하이퍼스탯 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterHyperStat(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/hyper-stat';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterHyperStatDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 성향 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterPropensity(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/propensity';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterPropensityDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 어빌리티 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterAbility(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/ability';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterAbilityDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 장착한 장비 중 캐시 장비를 제외한 나머지 장비 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterItemEquipment(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/item-equipment';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterItemEquipmentDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 장착한 캐시 장비 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterCashItemEquipment(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/cashitem-equipment';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterCashItemEquipmentDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 장착한 심볼 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterSymbolEquipment(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/symbol-equipment';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterSymbolEquipmentDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 적용받고 있는 세트 효과 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterSetEffect(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/set-effect';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterSetEffectDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 장착 중인 헤어, 성형, 피부 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterBeautyEquipment(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/beauty-equipment';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterBeautyEquipmentDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 장착한 안드로이드 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterAndroidEquipment(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/android-equipment';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterAndroidEquipmentDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 장착한 펫 및 펫 스킬, 장비 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterPetEquipment(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/pet-equipment';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterPetEquipmentDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 캐릭터 스킬과 하이퍼 스킬 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param characterSkillGrade 조회하고자 하는 전직 차수
     *  - 0: 0차 스킬 및 제로 공용스킬
     *  - 1: 1차 스킬
     *  - 1.5: 1.5차 스킬
     *  - 2: 2차 스킬
     *  - 2.5: 2.5차 스킬
     *  - 3: 3차 스킬
     *  - 4: 4차 스킬 및 제로 알파/베타 스킬
     *  - hyperpassive: 하이퍼 패시브 스킬
     *  - hyperactive: 하이퍼 액티브 스킬
     *  - 5: 5차 스킬
     *  - 6: 6차 스킬
     *  @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterSkill(ocid, characterSkillGrade, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            character_skill_grade: characterSkillGrade,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/skill';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterSkillDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 장착 링크 스킬 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterLinkSkill(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/link-skill';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterLinkSkillDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * V매트릭스 슬롯 정보와 장착한 V코어 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterVMatrix(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/vmatrix';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterVMatrixDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * HEXA 매트릭스에 장착한 HEXA 코어 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterHexaMatrix(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/hexamatrix';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterHexaMatrixDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * HEXA 매트릭스에 설정한 HEXA 스탯 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterHexaMatrixStat(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/hexamatrix-stat';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterHexaMatrixStatDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 캐릭터 무릉도장 최고 기록 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 캐릭터 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getCharacterDojang(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/character/dojang';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CharacterDojangDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    //#endregion
    //#region 유니온 정보 조회
    /**
     * 유니온 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 유니온 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getUnionInfo(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/user/union';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new UnionDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 유니온 공격대 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 유니온 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.)
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param ocid 캐릭터 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getUnionRaiderInfo(ocid, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            ocid: ocid,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/user/union-raider';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query
            });
            return new UnionRaiderDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    //#endregion
    //#region 길드 정보 조회
    /**
     * 길드 식별자(oguild_id) 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 길드 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.).
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param guildName 길드 명
     * @param worldName 월드 명
     */
    async getGuild(guildName, worldName) {
        try {
            const path = 'maplestory/v1/guild/id';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: {
                    guild_name: guildName,
                    world_name: worldName,
                },
            });
            return new GuildDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 길드 기본 정보를 조회합니다.
     * - 2023년 12월 21일 데이터부터 조회할 수 있습니다.
     * - 길드 정보 조회 API는 일자별 데이터로 매일 오전 1시부터 전일 데이터 조회가 가능합니다. (예를 들어, 12월 22일 데이터를 조회하면 22일 00시부터 23일의 00시 사이의 데이터가 조회됩니다.).
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param guildId 길드 식별자
     * @param dateOptions 조회 기준일 (KST)
     */
    async getGuildBasic(guildId, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 1,
        minute: 0,
        dateOffset: 1
    })) {
        const query = {
            oguild_id: guildId,
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 21,
            }, dateOptions),
        };
        try {
            const path = 'maplestory/v1/guild/basic';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new GuildBasicDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    async getStarforceHistory(count, parameter) {
        const query = {
            count,
        };
        if (typeof parameter === 'string') {
            query.cursor = parameter;
        }
        else if (typeof parameter === 'object') {
            query.date = MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 27,
            }, parameter ?? MapleStoryApi.getProperDefaultDateOptions({
                hour: 0,
                minute: 0,
                dateOffset: 0
            }));
        }
        try {
            const path = 'maplestory/v1/history/starforce';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new StarforceHistoryResponseDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    async getCubeHistory(count, parameter) {
        const query = {
            count,
        };
        if (typeof parameter === 'string') {
            query.cursor = parameter;
        }
        else if (typeof parameter === 'object') {
            query.date = MapleStoryApi.toDateString({
                year: 2022,
                month: 11,
                day: 25,
            }, parameter ?? MapleStoryApi.getProperDefaultDateOptions({
                hour: 4,
                minute: 0,
                dateOffset: 1
            }));
        }
        try {
            const path = 'maplestory/v1/history/cube';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new CubeHistoryResponseDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    //#endregion
    //#region 랭킹 정보 조회
    /**
     * 종합 랭킹 정보를 조회합니다.
     * - 2023년 12월 22일 데이터부터 조회할 수 있습니다.
     * - 오전 8시 30분부터 오늘의 랭킹 정보를 조회할 수 있습니다.
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param filterOptions 검색 기준
     * @param dateOptions 조회 기준일 (KST).
     *
     */
    async getOverallRanking(filterOptions, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 8,
        minute: 30,
        dateOffset: 0
    })) {
        const query = {
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 22,
            }, dateOptions),
        };
        if (filterOptions) {
            const { worldName, worldType, characterClass, ocid, page } = filterOptions;
            query.world_name = worldName;
            query.world_type = worldType;
            query.class = characterClass;
            query.ocid = ocid;
            query.page = page;
        }
        try {
            const path = 'maplestory/v1/ranking/overall';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new OverallRankingResponseDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 유니온 랭킹 정보를 조회합니다.
     * - 2023년 12월 22일 데이터부터 조회할 수 있습니다.
     * - 오전 8시 30분부터 오늘의 랭킹 정보를 조회할 수 있습니다.
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param filterOptions 검색 기준
     * @param dateOptions 조회 기준일 (KST)
     */
    async getUnionRanking(filterOptions, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 8,
        minute: 30,
        dateOffset: 0
    })) {
        const query = {
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 22,
            }, dateOptions),
        };
        if (filterOptions) {
            const { worldName, ocid, page } = filterOptions;
            query.world_name = worldName;
            query.ocid = ocid;
            query.page = page;
        }
        try {
            const path = 'maplestory/v1/ranking/union';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new UnionRankingResponseDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 길드 랭킹 정보를 조회합니다.
     * - 2023년 12월 22일 데이터부터 조회할 수 있습니다.
     * - 오전 8시 30분부터 오늘의 랭킹 정보를 조회할 수 있습니다.
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param filterOptions 검색 기준
     * @param dateOptions 조회 기준일 (KST)
     */
    async getGuildRanking(filterOptions, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 8,
        minute: 30,
        dateOffset: 0
    })) {
        const query = {
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 22,
            }, dateOptions),
            ranking_type: 0,
        };
        if (filterOptions) {
            const { worldName, rankingType, ocid, page } = filterOptions;
            query.world_name = worldName;
            query.ranking_type = rankingType;
            query.ocid = ocid;
            query.page = page;
        }
        try {
            const path = 'maplestory/v1/ranking/guild';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new GuildRankingResponseDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 무릉도장 랭킹 정보를 조회합니다.
     * - 2023년 12월 22일 데이터부터 조회할 수 있습니다.
     * - 오전 8시 30분부터 오늘의 랭킹 정보를 조회할 수 있습니다.
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param filterOptions 검색 기준
     * @param dateOptions 조회 기준일 (KST)
     */
    async getDojangRanking(filterOptions, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 8,
        minute: 30,
        dateOffset: 0
    })) {
        const query = {
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 22,
            }, dateOptions),
            difficulty: 0,
        };
        if (filterOptions) {
            const { worldName, difficulty, characterClass, ocid, page } = filterOptions;
            query.world_name = worldName;
            query.difficulty = difficulty;
            query.class = characterClass;
            query.ocid = ocid;
            query.page = page;
        }
        try {
            const path = 'maplestory/v1/ranking/dojang';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new DojangRankingResponseDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 더 시드 랭킹 정보를 조회합니다.
     * - 2023년 12월 22일 데이터부터 조회할 수 있습니다.
     * - 오전 8시 30분부터 오늘의 랭킹 정보를 조회할 수 있습니다.
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param filterOptions 검색 기준
     * @param dateOptions 조회 기준일 (KST)
     */
    async getSeedRanking(filterOptions, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 8,
        minute: 30,
        dateOffset: 0
    })) {
        const query = {
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 22,
            }, dateOptions),
        };
        if (filterOptions) {
            const { worldName, ocid, page } = filterOptions;
            query.world_name = worldName;
            query.ocid = ocid;
            query.page = page;
        }
        try {
            const path = 'maplestory/v1/ranking/theseed';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new TheSeedRankingResponseDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    /**
     * 업적 랭킹 정보를 조회합니다.
     * - 2023년 12월 22일 데이터부터 조회할 수 있습니다.
     * - 오전 8시 30분부터 오늘의 랭킹 정보를 조회할 수 있습니다.
     * - 게임 콘텐츠 변경으로 ocid가 변경될 수 있습니다. ocid 기반 서비스 갱신 시 유의해 주시길 바랍니다.
     *
     * @param filterOptions 검색 기준
     * @param dateOptions 조회 기준일 (KST)
     */
    async getAchievementRanking(filterOptions, dateOptions = MapleStoryApi.getProperDefaultDateOptions({
        hour: 8,
        minute: 30,
        dateOffset: 0
    })) {
        const query = {
            date: MapleStoryApi.toDateString({
                year: 2023,
                month: 12,
                day: 22,
            }, dateOptions),
        };
        if (filterOptions) {
            const { ocid, page } = filterOptions;
            query.ocid = ocid;
            query.page = page;
        }
        try {
            const path = 'maplestory/v1/ranking/achievement';
            const response = await axios.get(path, {
                baseURL: MapleStoryApi.BASE_URL,
                timeout: this.timeout,
                headers: this.buildHeaders(),
                params: query,
            });
            return new AchievementRankingResponseDto(response.data);
        }
        catch (e) {
            if (e instanceof AxiosError) {
                const errorBody = e.response.data;
                throw new MapleStoryApiError(errorBody);
            }
            throw e;
        }
    }
    //#endregion
    /**
     * 서버 점검 정보를 조회합니다.
     */
    async getInspectionInfo() {
        const xmlBuilder = new xml2js.Builder();
        const soapEnvelop = {
            'soap:Envelope': {
                $: {
                    'xmlns:xsi': 'http://www.w3.org/2001/XMLSchema-instance',
                    'xmlns:xsd': 'http://www.w3.org/2001/XMLSchema',
                    'xmlns:soap': 'http://schemas.xmlsoap.org/soap/envelope/',
                },
                'soap:Body': {
                    GetInspectionInfo: {
                        $: {
                            xmlns: 'https://api.maplestory.nexon.com/soap/',
                        },
                    },
                },
            },
        };
        const baseUrl = 'https://api.maplestory.nexon.com/';
        const path = 'soap/maplestory.asmx';
        const headers = {
            SOAPAction: 'https://api.maplestory.nexon.com/soap/GetInspectionInfo',
            'Content-Type': 'text/xml; charset=utf-8',
        };
        const body = xmlBuilder.buildObject(soapEnvelop);
        const response = await axios.post(path, body, {
            baseURL: baseUrl,
            timeout: this.timeout,
            headers,
        });
        const xml = (await xml2js.parseStringPromise(response.data));
        return new InspectionInfoDto(xml);
    }
    buildHeaders() {
        return {
            'x-nxopen-api-key': this.apiKey,
        };
    }
    /**
     * API 서버의 데이터 갱신 시간에 따라 데이터가 조회 가능한 최신 날짜를 반환합니다.
     *
     * @param options
     * @private
     */
    static getProperDefaultDateOptions(options) {
        const { hour, minute, dateOffset } = options;
        const kstNow = dayjs().utcOffset(MapleStoryApi.kstOffset);
        const updateDate = dayjs()
            .utcOffset(MapleStoryApi.kstOffset)
            .hour(hour)
            .minute(minute);
        let adjustedDate;
        if (kstNow.isAfter(updateDate)) {
            adjustedDate = kstNow;
        }
        else {
            adjustedDate = kstNow.subtract(1, 'day');
        }
        adjustedDate = adjustedDate.subtract(dateOffset ?? 0, 'day');
        return {
            year: adjustedDate.year(),
            month: adjustedDate.month() + 1,
            day: adjustedDate.date()
        };
    }
    /**
     * 날짜 정보를 API 서버에서 요구하는 포맷으로 변환합니다.
     *
     * @param minDateOptions API 호출 가능한 최소 날짜
     * @param dateOptions 조회 하려는 날짜
     * @private
     */
    static toDateString(minDateOptions, dateOptions) {
        const { year: minYear, month: minMonth, day: minDay } = minDateOptions;
        const { year, month, day } = dateOptions;
        if (year < minYear ||
            (year === minYear && month < minMonth) ||
            (year === minYear && month === minMonth && day < minDay)) {
            throw new Error(`You can only retrieve data after ${dayjs(`${minYear}-${minMonth}-${minDay}`).format('YYYY-MM-DD')}.`);
        }
        return dayjs(`${year}-${month}-${day}`).utcOffset(MapleStoryApi.kstOffset).format('YYYY-MM-DD');
    }
}

export { AchievementRankingDto, AchievementRankingResponseDto, CharacterAbilityDto, CharacterAbilityInfoDto, CharacterAndroidCashItemEquipmentColoringPrismDto, CharacterAndroidCashItemEquipmentDto, CharacterAndroidCashItemEquipmentOptionDto, CharacterAndroidEquipmentDto, CharacterAndroidEquipmentFaceDto, CharacterAndroidEquipmentHairDto, CharacterBasicDto, CharacterBeautyEquipmentDto, CharacterBeautyEquipmentFaceDto, CharacterBeautyEquipmentHairDto, CharacterCashItemEquipmentColoringPrismDto, CharacterCashItemEquipmentDto, CharacterCashItemEquipmentOptionDto, CharacterCashItemEquipmentPresetDto, CharacterDojangDto, CharacterDto, CharacterHexaMatrixDto, CharacterHexaMatrixEquipmentDto, CharacterHexaMatrixEquipmentLinkedSkillDto, CharacterHexaMatrixStatCoreDto, CharacterHexaMatrixStatDto, CharacterHyperStatDto, CharacterHyperStatPresetDto, CharacterItemEquipmentAddOptionDto, CharacterItemEquipmentBaseOptionDto, CharacterItemEquipmentDto, CharacterItemEquipmentEtcOptionDto, CharacterItemEquipmentExceptionalOptionDto, CharacterItemEquipmentInfoDto, CharacterItemEquipmentStarforceOptionDto, CharacterItemEquipmentTitleDto, CharacterItemEquipmentTotalOptionDto, CharacterLinkSkillDto, CharacterLinkSkillInfoDto, CharacterPetEquipmentAutoSkillDto, CharacterPetEquipmentDto, CharacterPetEquipmentItemDto, CharacterPetEquipmentItemOptionDto, CharacterPopularityDto, CharacterPropensityDto, CharacterSetEffectDto, CharacterSetEffectInfoDto, CharacterSetEffectOptionInfoDto, CharacterSkillDto, CharacterSkillInfoDto, CharacterStatDto, CharacterSymbolEquipmentDto, CharacterSymbolEquipmentInfoDto, CharacterVMatrixCodeEquipmentDto, CharacterVMatrixDto, CubeHistoryDto, CubeHistoryResponseDto, CubeResultOptionDto, DojangRankingDto, DojangRankingResponseDto, GuildBasicDto, GuildDto, GuildRankingDto, GuildRankingResponseDto, GuildSkillDto, InspectionInfoDto, MapleStoryApi, MapleStoryApiError, MapleStoryApiErrorCode, OverallRankingDto, OverallRankingResponseDto, PotentialOptionGrade, StarforceEventDto, StarforceHistoryDto, StarforceHistoryResponseDto, TheSeedRankingDto, TheSeedRankingResponseDto, UnionDto, UnionRaiderBlockControlPointDto, UnionRaiderBlockDto, UnionRaiderBlockPositionDto, UnionRaiderDto, UnionRaiderInnerStatDto, UnionRankingDto, UnionRankingResponseDto, potentialOptionGradeFromString };
